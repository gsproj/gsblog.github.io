---
title: 01-C++核心编程
date: 2023-3-27 9:24:22
categories:
- C++
- 05_C++核心编程
tags:
---

# <font color=blue>一、C++ 概述</font>

## <font color=darkyellow>1.1 C++简介</font>

什么是C++？

- c++中的++来自于c语言中的递增运算符++，该运算符将变量加1。c++起初也叫**c with clsss**，通过名称表明。
- c++是对C的扩展加强，因此c++是c语言的超集，是一种更好的C语言，这意味着任何有效的c程序都是有效的c++程序。c++程序可以使用已有的c程序库。
- c++语言在c语言的基础上添加了**面向对象编程**和**泛型编程**的支持。c++继承了c语言高效，简洁，快速和可移植的传统。

c++融合了3种不同的编程方式:

- c语言代表的过程性语言
- c++在c语言基础上添加的类代表的面向对象语言
- c++模板支持的泛型编程

# <font color=blue>二、C++初识</font>

## <font color=darkyellow>2.1 简单C++程序</font>

### <font color=green>2.2.1 HelloWorld代码</font>

C++的HelloWorld代码如下：

```c++
#include <iostream>	// 预编译指令
using namespace std;	// 使用标准命名空间

int main() {
	cout << "Hello World!" << endl;	// 和printf功能一样
	return 0;
}
```

### <font color=green>2.2.2 C++的头文件</font>

c++头文件为什么没有.h？

在c语言中头文件使用扩展名`.h`,将其作为一种通过名称标识文件类型的简单方式。但是c++得用法改变了，c++头文件没有扩展名。但是有些c语言的头文件被转换为c++的头文件，这些文件被重新命名，丢掉了扩展名.h(使之成为c++风格头文件)，并在文件名称前面加上前缀c(表明来自c语言)。

> 例如c++版本的math.h为cmath

由于C使用不同的扩展名来表示不同文件类型，因此用一些特殊的扩展名(如hpp或hxx)表示c++的头文件也是可以的，ANSI/IOS标准委员会也认为是可以的，但是关键问题是用哪个比较好，最后一致同意不使用任何扩展名。

| 头文件类型  | 约定               | 示例       | 说明                                        |
| ----------- | ------------------ | ---------- | ------------------------------------------- |
| c++旧式风格 | 以.h结尾           | iostream.h | c++程序可用                                 |
| c旧式风格   | 以.h结尾           | math.h     | c/c++程序可用                               |
| c++新式风格 | 无扩展名           | iostream   | c++程序可用，使用namespace std              |
| 转换后的c   | 加上前缀c,无扩展名 | cmath      | c++程序可用，可使用非c特性，如namespace std |

# <font color=blue>三、C++对C的扩展</font>

## <font color=darkyellow>3.1 `::`作用域运算</font>

通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。

```c++
//全局变量
int a = 10;
void test(){
	//局部变量
	int a = 20;
	//全局a被隐藏
	cout << "a = " << a << endl;	// 输出:a = 20
}
```

程序的输出结果是`a = 20`在test函数的输出语句中，使用的变量a是test函数内定义的局部变量，因此输出的结果为局部变量a的值。作用域运算符可以用来解决局部变量与全局变量的重名问题 ，如以下案例：

```c++
//全局变量
int a = 10;
//1. 局部变量和全局变量同名
void test(){
	int a = 20;
	//打印局部变量a
	cout << "局部变量a:" << a << endl;	// 20
	//打印全局变量a
	cout << "全局变量a:" << ::a << endl;	// 10
}
```

## <font color=darkyellow>3.2 命名空间</font>

创建`名字(name)`是程序设计过程中一项最基本的活动，当一个项目很大时，它会不可避免地包含大量名字，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等，工程越大，名称互相冲突性的可能性越大。另外使用多个厂商的类库时，也可能导致名称冲突，为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字`namespace`（命名空间/名字空间/名称空间），可以更好地控制标识符的作用域。

### <font color=green>3.2.1 命名空间的使用</font>

命名空间的常用方法

#### 3.2.1.1 创建命名空间

```c++
namespace A{
	int a = 10;
}
namespace B{
	int a = 20;
}
void test(){
	cout << "A::a : " << A::a << endl; // 10
	cout << "B::a : " << B::a << endl; // 20
}
```

> 命名空间只能全局范围内定义（**以下错误写法**）
>
> ```c++
> void test(){
> 	namespace A{	// error
> 		int a = 10;
> 	}
> 	namespace B{	// error
> 		int a = 20;
> 	}
> 	cout << "A::a : " << A::a << endl;
> 	cout << "B::a : " << B::a << endl;
> }
> 
> ```

#### 3.2.1.2 命名空间嵌套

命名空间可以嵌套使用

```c++
namespace A{
	int a = 10;
	namespace B{
		int a = 20;
	}
}
void test(){
	cout << "A::a : " << A::a << endl;
	cout << "A::B::a : " << A::B::a << endl;
}
```

#### 3.2.1.3 追加成员

命名空间是开放的，即可以随时把新的成员加入已有的命名空间中

```c++
namespace A{
	int a = 10;
}

// 往命名空间中追加新成员
namespace A{
	void func(){
		cout << "hello namespace!" << endl;
	}
}

void test(){
	cout << "A::a : " << A::a << endl;
	A::func();
}
```

#### 3.2.1.4 声明和实现分离

头文件声明

```c++
#pragma once

namespace MySpace{
	void func1();
	void func2(int param);
}
```

cpp文件实现

```c++
void MySpace::func1(){
	cout << "MySpace::func1" << endl;
}
void MySpace::func2(int param){
	cout << "MySpace::func2 : " << param << endl;
}
```

#### 3.2.1.5 无命名的空间

无名命名空间，意味着命名空间中的标识符**只能在本文件内访问**，相当于给这个标识符加上了static，使得其可以作为内部连接

```c++
namespace {	// 没有名字
	int a = 10;
	void func(){ cout << "hello namespace" << endl; }
}

void test(){
	cout << "a : " << a << endl;
	func();
}
```

#### 3.2.1.6 命名空间别名

命名空间可以设置别名，调用方法是一样的

```c++
// 创建命名空间
namespace veryLongName{
	int a = 10;
	void func(){ cout << "hello namespace" << endl; }
}

void test(){
    // 给命名空间创建别名
	namespace shortName = veryLongName;
	
    // 通过别名使用命名空间
    cout << "veryLongName::a : " << shortName::a << endl;
	veryLongName::func();
	shortName::func();
}
```

### <font color=green>3.2.2 using声明</font>

#### 3.2.2.1 using声明单个标识符

using声明可使得指定的标识符可用。

```c++
namespace A{
	int paramA = 20;
	int paramB = 30;
	void funcA(){ cout << "hello funcA" << endl; }
	void funcB(){ cout << "hello funcA" << endl; }
}

void test(){
	// 1. 通过命名空间直接访问
	cout << A::paramA << endl;
	A::funcA();
    
	// 2. 使用using声明单个标识符来访问
	using A::paramA;
	using A::funcA;
	cout << paramA << endl;
    
	// cout << paramB << endl; // 不可直接访问
	funcA();	// using声明过可以直接访问
    
	// 3. 同名冲突
	//int paramA = 20; // 相同作用域注意同名冲突
}
```

#### 3.2.2.2 using声明碰到函数重载

如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。

```c++
namespace A{
	void func(){}
	void func(int x){}
	int  func(int x,int y){}
}

void test(){
	using A::func;
    
    // 以下三个调用都能正常使用
	func();
	func(10);
	func(10, 20);
}
```

#### 3.2.2.3 using声明整个命令空间

using编译指令使整个命名空间的标识符可用.

```c++
namespace A{
	int paramA = 20;
	int paramB = 30;
	void funcA(){ cout << "hello funcA" << endl; }
	void funcB(){ cout << "hello funcB" << endl; }
}

void test01(){
	using namespace A;
	cout << paramA << endl;
	cout << paramB << endl;
	funcA();
	funcB();

	//不会产生二义性
	int paramA = 30;
	cout << paramA << endl;
}

namespace B{
	int paramA = 20;
	int paramB = 30;
	void funcA(){ cout << "hello funcA" << endl; }
	void funcB(){ cout << "hello funcB" << endl; }
}

void test02(){
	using namespace A;
	using namespace B;
	//二义性产生，不知道调用A还是B的paramA
	//cout << paramA << endl;
}
```

## <font color=darkyellow>3.3 全局变量检测增强</font>

C++在C语言的基础上增强了对全局变量的检测，如以下代码，在C编译器中将编译成功，在C++编译器中将编译失败：

```c++
int a = 10;
int a;

int main() {
    printf("%d\n", a);
    return 0;
}
```

编译执行结果：

```shell
gs@GreatWall-greatwall:~/C-Demo$ gcc test.c
gs@GreatWall-greatwall:~/C-Demo$ ./a.out
10
gs@GreatWall-greatwall:~/C-Demo$ g++ test.c
test.c:4:5: 错误： ‘int a’ 重定义
    4 | int a;
      |     ^
test.c:3:5: 附注： ‘int a’ previously defined here
    3 | int a = 10;
      |     ^
```

## <font color=darkyellow>3.4 所有的变量和函数必须有类型</font>

C++中所有的变量和函数都必须有类型，如以下代码，在C中可以编译执行，在C++中失败

```c
#include <stdio.h>

// 形参i不指定类型，实参可以是任意类型
int func1(i) {
    printf("i = %d\n", i);
    return 0;
}

// 形参i不指定类型，实参可以是任意类型
int func2(i) {
    printf("i = %s\n", i);
    return 0;
}

// 不写形参，可以传任何实参
int func3() {
    printf("func33\n");
    return 0;
}

// C语言如果没有参数，建议写void，代表没有参数
int func4(void) {
    printf("func4\n");
    return 0;
}

// 返回值没有类型
func5() {
    return 10;
}

// 返回值没有类型
func6() {
    return "Good Job";
}

int main() {
    func1(10086);
    func2("这是移动的电话");
    func3();
    func4();
    printf("func5的执行结果: %d\n", func5);
    printf("func6的执行结果: %s\n", func6);
    return 0;
}
```

编译执行结果：

```shell
# gcc编译成功
gs@GreatWall-greatwall:~/C-Demo$ gcc test.c
test.c: 在函数‘func1’中:
test.c:4:5: 警告： ‘i’的类型默认为‘int’ [-Wimplicit-int]
    4 | int func1(i) {
      |     ^~~~~
test.c: 在函数‘func2’中:
test.c:10:5: 警告： ‘i’的类型默认为‘int’ [-Wimplicit-int]
   10 | int func2(i) {
      |     ^~~~~
test.c: 在文件作用域：
test.c:28:1: 警告： 返回类型默认为‘int’ [-Wimplicit-int]
   28 | func5() {
      | ^~~~~
test.c:33:1: 警告： 返回类型默认为‘int’ [-Wimplicit-int]
   33 | func6() {
      | ^~~~~
test.c: 在函数‘func6’中:
test.c:34:12: 警告： returning ‘char *’ from a function with return type ‘int’ makes integer from pointer without a cast [-Wint-conversion]
   34 |     return "Good Job";
      |            ^~~~~~~~~~

# 执行成功
gs@GreatWall-greatwall:~/C-Demo$ ./a.out
i = 10086
i = 这是移动的电话
func33
func4
func5的执行结果: 10
func6的执行结果: Good Job

# g++编译失败
gs@GreatWall-greatwall:~/C-Demo$ g++ test.c
test.c:4:11: 错误： ‘i’在此作用域中尚未声明
    4 | int func1(i) {
      |           ^
test.c:10:11: 错误： ‘i’在此作用域中尚未声明
   10 | int func2(i) {
      |           ^
test.c:28:7: 错误： ISO C++ 不允许声明无类型的‘func5’ [-fpermissive]
   28 | func5() {
      |       ^
test.c:33:7: 错误： ISO C++ 不允许声明无类型的‘func6’ [-fpermissive]
   33 | func6() {
      |       ^
test.c: 在函数‘int func6()’中:
test.c:34:12: 错误： invalid conversion from ‘const char*’ to ‘int’ [-fpermissive]
   34 |     return "Good Job";
      |            ^~~~~~~~~~
      |            |
      |            const char*
test.c: 在函数‘int main()’中:
test.c:38:16: 错误： ‘func1’ cannot be used as a function
   38 |     func1(10086);
      |                ^
test.c:39:34: 错误： ‘func2’ cannot be used as a function
   39 |     func2("这是移动的电话");
      |                                  ^
```

>在C语言中，int fun() 表示返回值为int，接受任意参数的函数，int fun(void) 表示返回值为int的无参函数。
>
>在C++ 中，int fun() 和int fun(void) 具有相同的意义，都表示返回值为int的无参函数。

## <font color=darkyellow>3.5 更严格的类型转换</font>

在C++中不同类型的变量一般是不能直接赋值的，需要相应的强制类型转换，比如以下代码，在C下可编译通过，C++下编译失败：

```c
#include <stdio.h>
#include <stdlib.h>

typedef enum COLOR{
    GREEN, RED, YELLOW
}color;

int main() {
    color mycolor = GREEN;
    mycolor = 10;	// C++: invalid conversion from ‘int’ to ‘color’
    printf("mycolor: %d\n", mycolor);
    char* p = malloc(10); // C++: invalid conversion from ‘void*’ to ‘char*’
    return 0;
}
```

编译执行结果：

```shell
# gcc编译成功
gs@GreatWall-greatwall:~/C-Demo$ gcc test.c
gs@GreatWall-greatwall:~/C-Demo$ ./a.out
mycolor: 10
# g++编译失败
gs@GreatWall-greatwall:~/C-Demo$ g++ test.c
test.c: 在函数‘int main()’中:
test.c:10:15: 错误： invalid conversion from ‘int’ to ‘color’ {aka ‘COLOR’} [-fpermissive]
   10 |     mycolor = 10;
      |               ^~
      |               |
      |               int
test.c:12:21: 错误： invalid conversion from ‘void*’ to ‘char*’ [-fpermissive]
   12 |     char* p = malloc(10);
      |               ~~~~~~^~~~
      |                     |
      |                     void*
```

## <font color=darkyellow>3.6 struct类型加强</font>

改动有两方面：

- C中的结构体只能定义成员变量，不能定义成员函数，而C++的都可以定义
- C中定义结构体变量需要加上struct关键字，C++不需要

```c
#include <iostream>
using namespace std;

struct Student {
	// 既可以定义成员变量
	char name[64];
	int age;

	// 又可以定义成员函数
	int getAge() {
		return this->age;
	}
};

int main() {
	// 使用的时候还不需要struct
	// struct Student stu1;
	Student stu1 = { "张三", 18 };
	int age = stu1.getAge();
	printf("stu1 name = %s, age = %d\n", stu1.name, age);
}
```

## <font color=darkyellow>3.7 bool类型</font>

C++新增bool类型：true和false，转换为整形分别是1和0

- bool类型只有两个值，true(1值)，false(0值)
- bool类型占1个字节大小

```c++
#include <iostream>
using namespace std;

int main() {
	// 使用bool类型
	bool isEmpty = false;
	printf("isEmpty = %d\n", isEmpty);
}
```

>其实c语言中也有bool类型：
>
>在c99标准之前是没有bool关键字，c99标准已经有bool类型，包含头文件stdbool.h,就可以使用和c++一样的bool类型。

## <font color=darkyellow>3.8 三目运算符功能增强</font>

语言三目运算表达式返回值为数据值，为右值，不能赋值

```c
int a = 10;
int b = 20;
printf("ret:%d\n", a > b ? a : b);
//返回的是右值:10
```

c++语言三目运算表达式返回值为变量本身(引用)，为左值，可以赋值。

```c++
int a = 10;
int b = 20;
printf("ret:%d\n", a > b ? a : b);
//返回的是左值，变量的引用:b

(a > b ? a : b) = 100;//返回的是左值，变量的引用
cout << "b:" << b << endl;
```

## <font color=darkyellow>3.9 const常量的改变</font>

const单词表面意思为常数---不变的数，它在C/C++里面都有，是一个关键字，用于限定变量不允许修改（只读），它可以将一个对象转换成一个常量。

### <font color=green>3.9.1 常量能否被修改</font>

#### 3.9.1.1 全局const变量

**<font color=red>对于全局变量，都不可以修改</font>**

C/C++全局const变量的在内存中的存储位置：

- c语言中全局const会被存储到只读数据段。
- c++中全局const当声明extern或者对变量取地址时，编译器会分配存储地址，变量存储在只读数据段。

两个都受到了只读数据段的保护，不可修改。

```c
const int constA = 10;
int main() {
	int* p = (int*)&constA;
    *p = 200;
}
```

以上代码在c/c++中编译通过，在运行期，修改constA的值时，发生写入错误。原因是修改只读数据段的数据。

#### 3.9.1.2 局部const变量 

**<font color=red>对于局部变量，C可以改，C++不可以改</font>**

C语言中的局部const变量是假const变量：

- C语言中局部const可以通过指针修改。存储在堆栈区，只是不能通过变量直接修改const只读变量的值，但是可以跳过编译器的检查，通过指针间接修改const值。
- C++中局部const变量不可修改

```c
const int constA = 10;
int* p = (int*)&constA;
*p = 300;
printf("constA:%d\n",constA);
printf("*p:%d\n", *p);
```

c语言中，通过指针间接赋值修改了constA的值。

### <font color=green>3.9.2 C++局部const变量的内存分配</font>

#### 3.9.2.1 普通常量的内存分配1

对于基础数据类型，也就是`const int a = 10`这种，编译器会把它放到符号表中，不分配内存，当对其取地址时，会分配内存。

```c++
// 刚创建，不会分配内存，放到符号表中
const int constA = 10;
// 对其取地址时，会分配内存
int* p = (int*)&constA;
*p = 300;
cout << "constA:" << constA << endl;
cout << "*p:" << *p << endl;
```

constA在符号表中，当我们对constA取地址，这个时候为constA分配了新的空间，*p操作的是分配的空间，而constA是从符号表获得的值。

#### 3.9.2.2 普通常量的内存分配2

对于基础数据类型，如果用一个变量初始化const变量，如果const int a = b,那么也是会给a分配内存。

```c
int b = 10;
// constA 分配了内存，所以我们可以修改constA内存中的值
const int constA = b;
int* p = (int*)&constA;
*p = 300;
cout << "constA:" << constA << endl;
cout << "*p:" << *p << endl;
```

#### 3.9.2.3 自定义数据类型的内存分配

对于自定数据类型，比如类对象，那么也会分配内存。

```c
const Person person; //未初始化age
//person.age = 50; //不可修改
Person* pPerson = (Person*)&person;
//指针间接修改
pPerson->age = 100;
cout << "pPerson->age:" << pPerson->age << endl;
pPerson->age = 200;
cout << "pPerson->age:" << pPerson->age << endl;
```

为person分配了内存，所以我们可以通过指针的间接赋值修改person对象。

#### 3.9.2.4 内部连接和外部连接

C/C++默认的连接方式不一样

- c中const默认为外部连接
- c++中const默认为内部连接

当c语言**两个文件中**都有const int a的时候，编译器会报重定义的错误。

而在c++中，则不会，因为c++中的const默认是内部连接的。

如果想让c++中的const具有外部连接，必须显示声明为: extern const int a = 10;

案例如下：

文件test2.h

```c
const int a = 10;
```

文件test.c

```c
#include <stdio.h>
#include <stdlib.h>

// main.cpp定义
const int a = 10;

int main() {
        printf("a = %d\n", a);
        return 0;
}
```

编译并运行

```shell
# gcc编译失败，默认是外部连接，所以能探测到
gs@GreatWall-greatwall:~/C-Demo$ gcc test.c test2.c -o a.out
/usr/bin/ld: /tmp/ccHq7xrV.o:(.rodata+0x0): multiple definition of `a'; /tmp/cc2gZPeU.o:(.rodata+0x0): first defined here
collect2: 错误： ld 返回 1

# g++编译成功，默认是内部连接，只在test2.c中可见，所以探测不到
gs@GreatWall-greatwall:~/C-Demo$ g++ test.c test2.c -o a.out

# 执行
gs@GreatWall-greatwall:~/C-Demo$ ./a.out
a = 10
```

那么如何在C++中，将const常量改为外部连接？需要使用到`extern`修饰

文件test2.h

```c
extern const int a = 10;
```

文件test.c

```c
#include <stdio.h>
#include <stdlib.h>
// 引用外部变量
extern int a;


// main.cpp定义
// const int a = 10;

int main() {
        printf("a = %d\n", a);
        return 0;
}
```

执行结果：

```c
a = 10
```

如果这两个代码文件没有extern就编译：

```shell
# gcc编译通过，默认外部连接
gs@GreatWall-greatwall:~/C-Demo$ gcc test.c test2.c
gs@GreatWall-greatwall:~/C-Demo$ ./a.out
a = 10

# g++编译失败，找不到定义
gs@GreatWall-greatwall:~/C-Demo$ g++ test.c test2.c
/usr/bin/ld: /tmp/ccYQmUru.o: in function `main':
test.c:(.text+0x8): undefined reference to `a'
/usr/bin/ld: test.c:(.text+0xc): undefined reference to `a'
collect2: 错误： ld 返回 1
```

>**扩展**：能否用变量定义数组:
>
>在支持c99标准的编译器中，可以使用变量定义数组。
>
>1. 微软官方描述vs2013编译器不支持c99.： （VS不可以）
>
>Microsoft C conforms to the standard for the C language as set forth in the 9899:1990 edition of the ANSI C standard. 
>
>2. 以下代码在Linux GCC支持c99编译器编译通过	（GCC可以）
>
>```c
>// 定义变量
>int a = 10;
>// 用变量定义数组
>int arr[a];
>
>// 赋值并输出
>int i = 0;
>for(; i<10; i++) {
>    arr[i] = i;
>	i = 0;
>} 
>
>for(;i<10;i++) {
>   printf("%d\n",arr[i]); 
>}
>```

### <font color=green>3.9.3 const和define的区别</font>

**C++中尽量用const替换#define**

在旧版本C中，如果想建立一个常量，可以使用预处理器

```c
#define MAX 1024;
```

我们定义的宏MAX**从未被编译器看到过**，因为在**预处理阶段，所有的MAX已经被替换为了1024**，于是MAX并没有将其加入到符号表中。但我们使用这个常量获得一个编译错误信息时，可能会带来一些困惑，因为这个信息可能会提到1024，但是并没有提到MAX.如果MAX被定义在一个不是你写的头文件中，你可能并不知道1024代表什么，也许解决这个问题要花费很长时间。

解决办法就是用一个常量替换上面的宏。

```c
const int max= 1024;
```

它们两个主要有以下区别：

| 对比项  | 是否有类型                       | 是否有作用域                                                 |
| ------- | -------------------------------- | ------------------------------------------------------------ |
| const   | 有类型，可进行编译器类型安全检查 | const有作用域                                                |
| #define | 无类型，不可进行类型检查.        | #define不重视作用域，默认定义到文件结尾或者遇到undef，如果定义在指定作用域下有有效的常量，那么#define就不能用。 |

>**扩展**：宏常量可以有命名空间吗？可以在命名空间中声明，但不能通过命名空间访问
>
>```c
>namespace MySpace{
>	#define num 1024	// 可以定义
>}
>void test(){
>	//cout << MySpace::NUM << endl; // 访问错误
>	//int num = 100; // 命名冲突
>	cout << num << endl;
>}
>```

## 3.10 引用（reference）

### <font color=green>3.10.1 引用的基本用法</font>

引用是C++对C的重要扩充，在C/C++指针的作用基本是一样的，但是C++增加了另外一种给函数传递地址的途径，这就是按照引用传递(pass-by-refernce)，他也存在与其他一些编程语言，并不是C++独有。

- 变量名实质上是一段连续内存空间的别名，是一个标号（门牌号）
- 程序中通过变量来申请并命名内存空间
- 通过变量的名字可以使用存储空间

> **对一段连续的内存空间只能取一个别名吗？**
>
>c++中新增了引用的概念，引用可以作为一个已定义变量的别名。

基本语法：

```c
type& ref = val;
```

案例：变量引用

```c++
#include <iostream>
using namespace std;

void test01() {
	int a = 10;
	// 给变量取一个别名
	int& b = a;
	cout << "a: " << a << endl;
	cout << "b: " << b << endl;
	cout << "----------------" << endl;

	// 操作b就相当于操作a本身
	b = 100;
	cout << "a: " << a << endl;	// 100
	cout << "b: " << b << endl;	// 100
	cout << "----------------" << endl;

	// 一个变量可以有n个别名
	int& c = a;
	c = 200;
	cout << "a: " << a << endl;	// 200
	cout << "b: " << b << endl;	// 200
	cout << "c: " << c << endl;	// 200
	cout << "----------------" << endl;

	// a,b,c 地址都是相同的
	cout << "a address: " << &a << endl;	// 0000004D9E6FF964
	cout << "b address: " << &b << endl;	// 0000004D9E6FF964
	cout << "c address: " << &c << endl;	// 0000004D9E6FF964
}

int main() {
	test01();
	return 0;
}
```

案例：数组引用

### <font color=green>3.10.2 引用注意事项</font>

使用引用的时候有如下注意事项：

- &在这不是求地址运算，而是起标识作用。

- 类型标识符是指目标变量的类型

  ```c++
  int a = 10;
  // Type& b = a; 这的Type是变量a的类型int
  int& b = a; 
  ```

- 必须在声明引用变量时进行初始化。

  ```c++
  // 引用必须初始化
  int& ref;	// err: ref必须初始化
  ```

- <del>引用初始化之后不能改变</del>（作废，在window和linux测试都能正常编译运行）

  ```c
  int a = 100;
  int b = 200;
  int& c = a;
  cout << "c = " << c << endl;	// 100
  c = b;
  cout << "c = " << c << endl;	// 200
  ```

- 不能有NULL引用。必须确保引用是和一块合法的存储单元关联。

  ```c++
  int& ref = NULL; // err: 无法从"int"转换为"int &"
  ```

- 不能直接建立对数组的引用，但是有方法创建

  ```c++
  int arr[3] = { 1,2,3 };
  int& ref[3] = arr; // err：ref引用数组是非法的
  ```

  可以通过如下2个方法引用数组：

  ```c++
  void test02() {
  	// 方法一：
  	typedef int ArrRef[10];
  	int arr[10];
  	ArrRef& aRef = arr;
  	// 赋值
  	for (int i = 0; i < 10; i++)
  	{
  		aRef[i] = i + 1;
  	}
  	// 输出
  	for (int i = 0; i < 10; i++) {
  		cout << arr[i] << " ";
  	}
  	cout << endl;
  
  	// 方法二：
  	int(&f)[10] = arr;
  	// 赋值
  	for (int i = 0; i < 10; i++)
  	{
  		f[i] = i + 1;
  	}
  	// 输出
  	for (int i = 0; i < 10; i++) {
  		cout << arr[i] << " ";
  	}
  }
  ```


### <font color=green>3.10.3 函数中的引用</font>

最常使用到引用的地方：函数参数和返回值

#### 3.10.3.1 参数引用

函数参数传递分为三种：

- 值传递
- 地址传递
- 引用传递

当引用作为函数参数时，称为**引用传递**

当引用被用作函数参数时，在**函数内**对任何引用的**修改**，将对**函数外**的参数**产生改变**。

当然，可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。

以下案例分别演示**值传递、地址传递、引用传递**三种参数的传递方式：

```c++
#include <iostream>
using namespace std;

// 值传递
void test01(int m, int n) {
	int temp = m;
	m = n;
	n = temp;
}

// 地址传递
void test02(int *m, int *n) {
	int temp = *m;
	*m = *n;
	*n = temp;
}

// 引用传递
void test03(int& m, int& n) {
	int temp = m;
	m = n;
	n = temp;
}

int main() {
	int a = 100;
	int b = 200;

	//test01(a, b);	
	//cout << "a = " << a << ", b = " << b << endl;	// 函数外的变量值没有被修改，100, 200
	//test02(&a, &b);
	//cout << "a = " << a << ", b = " << b << endl;	// 函数外的变量值被修改，200, 100
	test03(a, b);
	cout << "a = " << a << ", b = " << b << endl;	// 函数外的变量值被修改，200, 100

	return 0;
}
```

通过上述案例可以看出**引用参数**产生的效果同按**地址传递**是**一样的**。但是引用的语法更清楚简单：  

1. 函数调用时传递的实参不必加“&”符 
2. 在被调函数中不必在参数前加“*”符

引用作为其它变量的别名而存在，因此在一些场合可以代替指针。

**C++主张用引用传递取代地址传递的方式，因为引用语法容易且不易出错。**

将函数的形参定义为常量引用`(3.10.6节)`的好处:

- 引用不产生新的变量，减少形参与实参传递时的开销。

- 由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用

  ```c++
  // const int& num 防止函数中意外修改数据
  int getNum(const int& num) {
     	return num;
  }
  ```

#### 3.10.3.2 返回值引用

如果从函数中返回一个引用，必须像从函数中返回一个指针一样对待。

当函数返回值时，引用关联的内存一定要存在。以下是返回引用的案例

```c++
#include <iostream>
using namespace std;

// 返回局部变量的引用
int & test01() {
	int a = 10;
	return a;	// warn: 返回局部变量或临时变量的地址:a
}

// 返回静态变量的引用
int& test02() {
	static int a = 20;
	cout << "static int a = " << a << endl;
	return a;
}

int main() {
	// 不能返回局部变量的引用
	int &b = test01();
	cout << "b = " << b << endl; // -828547832 局部变量在栈中，用完就销毁了

	// 如果函数作左值，那么必须使用返回引用
	test02();	// static int a = 20
	test02() = 100; // static int a = 20
	test02(); // static int a = 100

	return 0;
}
```

### <font color=green>3.10.4 引用的本质</font>

引用的本质在C++内部实现是一个**指针常量**，比如

```c++
int &ref = num;
// 实际上是
int * const ref = &num;
```

c++编译器在编译过程中使用常指针作为引用的内部实现，因此**引用所占用的空间大小与指针相同**，只是这个过程是编译器内部实现，用户不可见。

```c++
void testFunc(int& ref){
	ref = 100; // ref是引用，转换为*ref = 100
}

int main(){
	int a = 10;
	int& aRef = a; // 自动转换为 int* const aRef = &a;这也能说明引用为什么必须初始化
	aRef = 20; // 内部发现aRef是引用，自动帮我们转换为: *aRef = 20;
	cout << "a:" << a << endl;	// 20
	cout << "aRef:" << aRef << endl;	// 20
	testFunc(a);
	return 0;
}
```

### <font color=green>3.10.5 指针引用</font>

在C语言中如果想改变一个指针的指向而不是它所指向的内容，函数声明可能这样:

```c
void fun(int**);
```

使用引用可以给指针变量取一个别名：

```c
Type* pointer = NULL;  
Type*& = pointer;
```

对于c++中的定义那个，语法清晰多了。函数参数变成指针的引用，用不着取得指针的地址。

```c++
struct Teacher{
	int mAge;
};

// 指针间接修改teacher的年龄
void AllocateAndInitByPointer(Teacher** teacher){
	*teacher = (Teacher*)malloc(sizeof(Teacher));
	(*teacher)->mAge = 200;  
}

// 引用修改teacher年龄
void AllocateAndInitByReference(Teacher*& teacher){
	teacher->mAge = 300;
}

void test(){
	//创建Teacher
	Teacher* teacher = NULL;
	
    //指针间接赋值
	AllocateAndInitByPointer(&teacher);
	cout << "AllocateAndInitByPointer:" << teacher->mAge << endl;
	
    //引用赋值,将teacher本身传到ChangeAgeByReference函数中
	AllocateAndInitByReference(teacher);
	cout << "AllocateAndInitByReference:" << teacher->mAge << endl;
	free(teacher);
}
```

### <font color=green>3.10.6 常量引用</font>

常量引用的定义格式

```c++
const Type& ref = val;
```

常量引用注意：

- 字面量不能赋给引用，但是可以赋给const引用。 字面量：诸如：整数、浮点数以及字符串
- const修饰的引用，不能修改。

```c++
void test01(){
	int a = 100;
	const int& aRef = a; //此时aRef就是a
	//aRef = 200; 不能通过aRef修改值
	a = 100; //OK
	cout << "a:" << a << endl;
	cout << "aRef:" << aRef << endl;
}

void test02(){
	//不能把一个字面量赋给引用
	//int& ref = 100;
	//但是可以把一个字面量赋给常引用
	const int& ref = 100; //int temp = 200; const int& ret = temp;
}
```

## <font color=darkyellow>3.11 内联函数(inline)</font>

### 3.11.1 内联函数概述

在C中，我们把一些短小、执行频繁的计算写成宏，而不是函数，这样可以提高执行效率，避免函数调用的开销，这些都由预处理来完成，但是在C++出现之后，继续使用宏会出现两个问题：

-  第一个在c中也会出现，宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误。
- 第二个问题是c++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类类的成员函数

为了保持预处理宏的效率、增加安全性，且还能像成员函数那样在类里访问，C++引入内联函数

内联函数为了继承宏函数的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为成员函数。

在c++中，预定义宏的概念是用内联函数来实现的，而**内联函数本身也是一个真正的函数**。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数**会在适当的地方像预定义宏一样展开**，所以不需要函数调用的开销。在C++中应该不使用宏，使用内联函数。

如何创建内联函数：在普通函数(非成员函数)函数前面加上inline关键字使之成为内联函数

但是必须注意必须**函数体**和**声明**结合在一起，否则编译器将它作为普通函数来对待。

```c++
 inline void func(int a);	// 没有函数体实现，编译器会将他视作普通函数
```

以上写法没有任何效果，仅仅是声明函数，应该如下方式来做:

```c++
// 正确的内联函数
inline int func(int a)
{
    return ++a;
}
```

> 编译器将会检查函数参数列表使用是否正确，并返回值(进行必要的转换)。这些是预处理宏无法完成的

内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈，跳转，返回的开销。我们可以理解为内联函数是以**空间换时间**。

### 3.11.2 预处理宏的缺陷

预处理宏有如下缺点：

1. 在预处理阶段被替换，不会进行类型检测，代码安全性低
2. 在预处理阶段展开–>不能调试
3. 每个使用部分都会展开---->造成代码膨胀
4. 容易出错，每个部分需要加括号
5. 宏函数可能会有副作用，如以下案例

使用预处理宏算出的实际计算结果跟期望值不符

```c++
#include <iostream>
using namespace std;

#define ADD(x, y) x + y
inline int Add(int x, int y) {
	return x + y;
}

int main() {
	int ret1 = ADD(10, 20) * 10; // 预期300， 实际结果210, 不符
	int ret2 = Add(10, 20) * 10; // 预期300， 实际结果300

	cout << "ret1 =" << ret1 << " ret2 = " << ret2 << endl;
	return 0;
}
```

原因是预处理宏只能做扩展操作

```c++
ADD(10, 20) * 10
// 扩展成
10 + 20 * 10 = 210
```

这个问题也可以解决，这样写就行了

```c++
#define ADD(x, y) (x + y)
```

### 3.11.3 内联函数原理

函数调用是需要额外开销的,假如有一些短小简单的函数被频繁调用,会大量消耗栈空间，比如以下代码：

```c++
//判断闰年
bool isLeapYear(int year){
    return (year%4==0 && year%100!=0) || year%400==0;
}

int leapYearsCount(vector<int>& years){
    int ans = 0;
    for(int i=0;i<years.size();++i){
        if(isLearYear(years[i])) ++ans;
    }
    return ans;
}
```

 `isLeapYear()`这个简单函数被多次调用,浪费栈空间和时间！有没有什么办法节约这部分开销，有人会这么写代码：

```c++
int leapYearsCount(vector<int>& years){
    int ans = 0;
    for(int i=0;i<years.size();++i){
        if(year%4==0&&year%100!=0)||year%400==0) ++ans;
    }
    return ans;
}
```

减少了多次调用函数的开销,但是破坏了函数的可读性,简单的说就是代码变丑了,代码会变的不易修改。

为了实现编译器自动替换函数体,我们可以通过**inline**关键字,将函数声明为**内联函数**。

```c++
//判断闰年,声明为内联函数
inline bool isLeapYear(int year){
    return (year%4==0&&year%100!=0)||year%400==0;
}

int leapYearsCount(vector<int>& years){
    int ans = 0;
    for(int i=0;i<years.size();++i){
        // 编译器将会自动替换
        if(isLearYear(years[i])) ++ans;
    }
    return ans;
}
```

这样既可以也函数形式在程序里使用isLeapYear(), 又不用在运行时承担额外开销。

### 3.11.4 类内部的内联函数

为了定义内联函数，通常必须在函数定义前面放一个inline关键字。但是在类内部定义内联函数时并不是必须的。任何在类内部定义的函数：编译器自动将其声明为内联函数。

```c++
class Person{
public:
	Person(){ cout << "构造函数!" << endl; }
	void PrintPerson(){ cout << "输出Person!" << endl; }
}
```

构造函数Person，成员函数PrintPerson在类的内部定义，自动成为内联函数。

### 3.11.5 内联函数的优缺点

> 优点

1. 它通过避免函数调用所带来的开销来提高你程序的运行速度。
2. 当函数调用发生时，它节省了变量弹栈、压栈的开销。
3. 它避免了一个函数执行完返回原现场的开销。
4. 通过将函数声明为内联，你可以把函数定义放在头文件内。

> 缺点：

1. 因为代码的扩展，内联函数增大了可执行程序的体积。
2. C++内联函数的展开是中编译阶段，这就意味着如果你的内联函数发生了改动，那么就需要重新编译代码。
3. 当你把内联函数放在头文件中时，它将会使你的头文件信息变多，不过头文件的使用者不用在意这些。
4. 有时候内联函数并不受到青睐，比如在嵌入式系统中，嵌入式系统的存储约束可能不允许体积很大的可执行程序。

**什么时候函数适合定义为内联？**

1. 函数尽量的短(<10行)
2. 函数简单(不能有复杂语句while,switch等)
3. 内联函数不能递归调用自己
4. 虚函数不能内联

> 注意:
> inline声明是对编译器的一种**建议**,编译器是否觉得采取你的建议取决于函数是否符合内联的有利条件。
> 如果**函数体非常大**，那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理。

## <font color=darkyellow>3.12 函数的默认参数</font>

C++在声明函数原型时可以为一个或者多个参数指定默认（缺省）值，当函数调用的时候如果没有指定参数的值，那么会默认使用缺省值。

```c++
void TestFunc01(int a = 10, int b = 20){
	cout << "a + b  = " << a + b << endl;
}
//注意点:
//1. 形参b设置默认参数值，那么后面位置的形参c也需要设置默认参数
void TestFunc02(int a,int b = 10,int c = 10){}
//2. 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不能再设置默认参数
void TestFunc03(int a = 0,int b = 0);	// 声明设置了默认参数
void TestFunc03(int a, int b){}	// 函数定义不能再设置

int main(){
	//1.如果没有传参数，那么使用默认参数
	TestFunc01();
	//2. 如果传一个参数，那么第二个参数使用默认参数
	TestFunc01(100);
	//3. 如果传入两个参数，那么两个参数都使用我们传入的参数
	TestFunc01(100, 200);

	return EXIT_SUCCESS;
}
```

## <font color=darkyellow>3.13 函数的占位参数</font>

C++在声明函数时，可以设置占位参数，占位参数**只有参数类型声明**，**没有参数名**的声明。一般情况下，在函数体内部无法使用占位参数。

```c++
// 设置占位参数"int"
void TestFunc01(int a,int b,int){
	//函数内部无法使用占位参数
	cout << "a + b = " << a + b << endl;
}
//占位参数也可以设置默认值
void TestFunc02(int a, int b, int = 20){
	//函数内部依旧无法使用占位参数
	cout << "a + b = " << a + b << endl;
}
int main(){
	//错误调用，占位参数也是参数，必须传参数
	//TestFunc01(10,20); 
	//正确调用
	TestFunc01(10,20,30);
	//正确调用
	TestFunc02(10,20);
	//正确调用
	TestFunc02(10, 20, 30);

	return EXIT_SUCCESS;
}
```

有什么用？操作符重载的后置++要用到这个

## <font color=darkyellow>3.14 函数重载</font>

什么是函数重载？

函数名相同：

- 在同一个作用域中
- 参数个数不同
- 参数类型不同
- 参数顺序不同

### 3.14.1 函数重载的基本语法

```c++
// 1. 函数重载条件
namespace A{
	void MyFunc(){ cout << "无参数!" << endl; }
	void MyFunc(int a){ cout << "a: " << a << endl; }
	void MyFunc(string b){ cout << "b: " << b << endl; }
	void MyFunc(int a, string b){ cout << "a: " << a << " b:" << b << endl;}
    void MyFunc(string b, int a){cout << "a: " << a << " b:" << b << endl;}
}
// 2.返回值不作为函数重载依据
namespace B{
	void MyFunc(string b, int a){}
	//int MyFunc(string b, int a){} //无法重载仅按返回值区分的函数
}
```

**注意:** 函数重载和默认参数一起使用，需要额外注意二义性问题的产生。

```c++
void MyFunc(string b){
	cout << "b: " << b << endl;
}
//函数重载碰上默认参数
void MyFunc(string b, int a = 10){
	cout << "a: " << a << " b:" << b << endl;
}
int main(){
	MyFunc("hello"); //这时，两个函数都能匹配调用，产生二义性
	return 0;
}
```

>**思考：**为什么函数返回值不作为重载条件呢？
>
>当编译器能从上下文中确定唯一的函数的时，如
>
>```c++
>int ret = func()
>```
>
>这个当然是没有问题的。然而，我们在编写程序过程中可以忽略他的返回值。那么这个时候,一个函数为
>
>```c++
>void func(int x)
>```
>
>另一个也为
>
>```c++
>int func(int x)
>```
>
>当我们直接调用func(10)，这个时候编译器就不确定调用那个函数。
>
>所以在c++中禁止使用返回值作为重载的条件。

### 3.14.2 函数重载的实现原理

编译器为了实现函数重载，也是默认为我们做了一些幕后工作：

编译器用不同的参数类型来修饰不同的函数名，比如void func(); 编译器可能会将函数名修饰成func，当编译器碰到void func(int x),编译器可能将函数名修饰为func_int,当编译器碰到void func(int x,char c),编译器可能会将函数名修饰为_func_int_char我这里使用”可能”这个字眼是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。

比如：

```c++
void func(){}
void func(int x){}
void func(int x,char y){}
```

以上三个函数在Linux下编译之后生成的函数名为

```c++
_Z4funcv //v 代表void,无参数
_Z4funci //i 代表参数为int类型
_Z4funcic //i 代表第一个参数为int类型，第二个参数为char类型
```

### 3.14.3 C++调用C

C++不能直接调用C函数，为什么？

以下的代码在Linux测试

```c++
c函数: void MyFunc(){} ,被编译成函数: MyFunc
c++函数: void MyFunc(){},被编译成函数: _Z6Myfuncv
```

由于C++中需要支持函数重载，所以C和C++中对同一个函数经过编译后生成的**函数名是不相同**的，这就导致了一个

问题，如果在c++中调用一个使用c语言编写模块中的某个函数，那么c++是根据c++的名称修饰方式来查找并链接这

个函数，那么就会发生链接错误，以上述例子来说，c++中调用MyFunc函数，在链接阶段会去找Z6Myfuncv，结果

是报错没有找到，因为这个MyFunc函数是c语言编写的，生成的符号是MyFunc。

如果想实现C++调用C代码，该如何操作？

```c++
extern "C"
```

它的主要作用就是为了实现c++代码能够调用其他c语言代码。加上extern "C"后，这部分代码编译器按c语言的方式

进行**编译**和**链接**，而不是按c++的方式。

#### 3.14.3.1 案例

> C头文件: MyModule.h

```c++
#pragma once

#include <stdio.h>

#if __cplusplus
extern "C" {
#endif

	void func1();
	int func2(int a, int b);

#if __cplusplus
}
#endif
```

> C定义文件: MyModule.c

```c
#include "MyModule.h"

void func1() {
	printf("成功调用func1!\n");
}

int func2(int x, int y) {
	int ret = x + y;
	printf("成功调用func2!, 返回:%d\n", ret);
	return ret;
}
```

> C++调用: main.cpp

```c++
#include <iostream>
#include "MyModule.h"
using namespace std;

void test01() {
	func1();
	int num = func2(9, 8);
}

int main() {
	test01();
	return 0;
}
```

执行结果:

```c++
成功调用func1!
成功调用func2!, 返回:17
```

如不设置`extern "C"`将报**无法解析的外部符号**错误

```c++
错误	LNK2019	无法解析的外部符号 "void __cdecl func1(void)" (?func1@@YAXXZ)，函数 "void __cdecl test01(void)" (?test01@@YAXXZ) 中引用了该符号	Project2	D:\桌面软件快捷方式\Temp\01-C++\Project2\Project2\源.obj	1	
```

