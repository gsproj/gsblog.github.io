---
title: 03-C++核心编程
date: 2023-4-26 9:42:22
categories:
- C++
- 05_C++核心编程
tags:
---

# 类和对象(二)

## 1.1 面向对象模型初探

### 1.1.1 成员变量和函数的存储

类的成员变量（数据）和成员函数（操作）是分开存储的：

- C++中的**非静态数据成员**是直接保存在类的对象的，就像c struct一样
- 成员函数虽然出现在类的声明中，但不保存在类的对象中
- 每一个**非内联成员函数**只会产生一份函数实例

如下演示案例：

```c++
#include <iostream>
using namespace std;

class MyClass01 {
public:
	int mA;	// 保存在类对象中，占4个字节
};

class MyClass02 {
public:
	int mA;	
	static int sB;	// 不保存在类对象中
};

class MyClass03 {
public:
	void printMyClass() {	// 不保存在类对象中
		cout << "Hello World！" << endl;
	}
public:
	int mA;
	static int sB;
};

class MyClass04 {
public:
	void printMyClass() {
		cout << "hello world!" << endl;
	}
	static void ShowMyClass() {	// 不保存在类对象中
		cout << "hello world！" << endl;
	}
public:
	int mA;
	static int sB;
};

int main() {
	MyClass01 mclass01;
	MyClass02 mclass02;
	MyClass03 mclass03;
	MyClass04 mclass04;

	cout << "MyClass01:" << sizeof(mclass01) << endl; //4
	//静态数据成员并不保存在类对象中
	cout << "MyClass02:" << sizeof(mclass02) << endl; //4
	//非静态成员函数不保存在类对象中
	cout << "MyClass03:" << sizeof(mclass03) << endl; //4
	//静态成员函数也不保存在类对象中
	cout << "MyClass04:" << sizeof(mclass04) << endl; //4

	return 0;
}
```

### 1.1.2 this指针

#### 1.1.2.1 this指针工作原理

通过上面的例子我们知道，C++的数据和操作也是分开存储，并且每一个非内联成员函数（non-inline member function）只会诞生一份函数实例，也就是说**多个同类型的对象会公用一块代码**

那么问题是，这一块代码是**如何区分到底是哪个对象调用自己的呢？**

![2016-05-10_213705](../../../img/clip_image002-1683684644687.jpg)

c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象。**

c++规定，this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的**每一个成员函数都含有一个**系统自动生成的**隐含指针this**，用以保存这个对象的地址，也就是说虽然我们没有写上this指针，编译器在编译的时候也是会加上的。因此this也称为“指向本对象的指针”，this指针并不是对象的一部分，不会影响sizeof(对象)的结果。

this指针是C++实现封装的一种机制，它将对象和该对象调用的成员函数连接在一起，在外部看来，每一个对象都拥有自己的函数成员。一般情况下，并不写this，而是让系统进行默认设置。

>   this指针永远指向当前对象。

成员函数通过this指针即可知道操作的是那个对象的数据。This指针是一种隐含指针，它隐含于每个类的非静态成员函数中。This指针无需定义，直接使用即可。

>注意：静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。

案例：c++编译器对普通成员函数的内部处理

![2016-04-12_010344](../../../img/clip_image002-1683688098742.jpg)

#### 1.1.2.2 this指针的使用

- 当形参和变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可使用return *this

案例如下：

```c++
#include <iostream>
#include <stdio.h>

using namespace std;

class Person {
public:
	// 1、当形参名和成员变量名一样时，this指针可用来区分
	Person(string name, int age) {
		this->name = name; // 区分this->name和name
		this->age = age;
	}

	// 2、返回对象本身的引用
	// 重载赋值操作
	// 其实也是两个参数，其中隐藏了一个this指针
	Person PersonPlusPerson(Person& person) {
		string newname = this->name + person.name;
		int newage = this->age + person.age;
		Person newperson(newname, newage);
		return newperson;
	}

	void ShowPerson() {
		cout << "Name: " << name << " Age: " << age << endl;
	}
public:
	string name;
	int age;
};

// 成员函数和全局函数(Person对象相加)
Person PersonPlusPerson(Person& p1, Person& p2) {
	string newname = p1.name + p2.name;
	int newage = p1.age + p2.age;
	Person newperson(newname, newage);
	return newperson;
}

int main() {
	Person p1("John", 100);
	p1.ShowPerson();

	cout << "-------" << endl;

	Person p2("Ladee", 20);
	Person p3("Oboo", 10);
	
	// 全局函数实现两个对象相加
	Person p4 = PersonPlusPerson(p2, p3);
	p2.ShowPerson();
	p3.ShowPerson();
	p4.ShowPerson();
	cout << "-------" << endl;


	// 成员函数实现两个对象相加
	Person p5 = p1.PersonPlusPerson(p2);
	p5.ShowPerson();

	system("pause");
}
```

#### 1.1.2.3 const修饰成员函数

作用如下：

- 用const修饰的成员函数时，const 修饰this指针指向的内存区域，成员函数体内不可以修改本类中的任何普通成员变量。
- 当成员函数变量类型符前用mutable修饰时例外。

使用案例：

```c++
#include <iostream>
using namespace std;

// const 修饰成员函数
class Person {
public:
	Person() {
		this->mAage = 0;
		this->mId = 0;
	}

	
	// 在函数括号后面加上const，修饰成员变量不可修改，除了mutable变量
	void someOperate() const {
		// this->mAage = 300; // mAge不可修改
		this->mId = 30;
	}

	void showPerson() {
		cout << "ID: " << this->mId << " Age: " << this->mAage;
	}

private:
	int mAage;
	mutable int mId;
};

int main() {
	Person p;
	p.someOperate();
	p.showPerson();	// ID: 30 Age: 0

	return 0;
}
```

#### 1.1.2.4 const修饰对象（常对象）

作用如下：

- 常对象只能调用const成员函数
- 常对象可访问const或非const数据成员，不能修改，除非成员用mutable修饰

```c++
#include <iostream>
using namespace std;

// const 修饰成员函数
class Person {
public:
	Person() {
		this->mAage = 0;
		this->mId = 0;
	}

	// 在函数括号后面加上const，修饰成员变量不可修改，除了mutable变量
	void someOperate() const {
		// this->mAage = 300; // mAge不可修改
		this->mId = 30;
	}

	void showPerson() {
		cout << "ID: " << this->mId << " Age: " << this->mAage;
	}

public:
	int mAage;
	mutable int mId;
};

int main() {
	// const 修饰对象
	const Person p;

	// 1、可访问数据成员, 但是不能修改, 除非有mutable修饰
	cout << "Age: " << p.mAage << ", ID: " << p.mId << endl;
	// p.mAage = 300; // 不可修改
	p.mId = 10; // 可以修改
	cout << "Age: " << p.mAage << ", ID: " << p.mId << endl;


	// 2、只能访问const修饰的成员函数
	p.someOperate(); // 可以访问
	// p.showPerson() // 不可访问

	return 0;
}
```

## 1.2 友元

什么是友元？

类的主要特点之一是**数据隐藏**，即类的私有成员无法在类的外部（作用域之外）访问。但是有时候**需要在类的外**

**部访问类的私有成员**，怎么办？

解决方法就是使用友元函数，友元函数是一种特权函数，C++允许这个特权函数访问私有成员。

这一点从现实生活中也很好理解：比如你的家，有客厅，有你的卧室，那么你的客厅是Public的，所有来的客人都

可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是呢，你也可以允许你的闺蜜好基友进去。

程序员可以把一个全局函数、某个类中的成员函数、甚至整个类声明为友元。

### 1.2.1 友元语法

使用方法如下：

- friend关键字只出现在声明处
- 其他类、类成员函数、全局函数都可声明为友元
- 友元函数不是类的成员，不带this指针
- 友元函数可访问对象任意成员属性，包括私有属性

案例：

```c++
#include <iostream>
using namespace std;

class Building;

// 友元类
class MyFriend {
public:
	// 友元成员函数
	void LookAtBedRoom(Building& building);
	void PlayInBedRoom(Building& building);
};

class Building {
	// 全局函数作为友元函数
	friend void CleanBedRoom(Building& building);

#if 0
	// 成员函数作为友元函数
	friend void MyFriend::LookAtBedRoom(Building& building);
	friend void MyFriend::PlayAtBedRoom(Building& building);
#else 
	friend class MyFriend;
#endif

public:
	Building();
public:
	string mSittingRoom;
private:
	string mBedroom;
};

void MyFriend::LookAtBedRoom(Building& building) {
	cout << "我的朋友参观" << building.mBedroom << endl;
}

void MyFriend::PlayInBedRoom(Building& building) {
	cout << "我的朋友玩耍" << building.mBedroom << endl;
}

// 友元全局函数
void CleanBedRoom(Building& building) {
	cout << "友元全局函数访问" << building.mBedroom << endl;
}

Building::Building() {
	this->mSittingRoom = "客厅";
	this->mBedroom = "卧室";
}

int main() {
	Building b;
	MyFriend m;

	CleanBedRoom(b);
	m.LookAtBedRoom(b);
	m.PlayInBedRoom(b);

	return 0;
}
```

>**<font color=red>友元类注意</font>**
>
>1．友元关系不能被继承。
>
>2．友元关系是单向的，类A是类B的朋友，但类B不一定是类A的朋友。
>
>友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。

**思考: c++是纯面向对象的吗？**

如果一个类被声明为friend,意味着它不是这个类的成员函数，却可以修改这个类的私有成员，而且必须列在类的定义中，因此他是一个特权函数。c++不是完全的面向对象语言，而只是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟c++设计的目的是为了实用性，而不是追求理想的抽象。

​                           																																											 --- Thinking in C++

### 1.2.2 课堂练习

请编写电视机类，电视机有开机和关机状态，有音量，有频道，提供音量操作的方法，频道操作的方法。由于电视

机只能逐一调整频道，不能指定频道，增加遥控类，遥控类除了拥有电视机已有的功能，再增加根据输入调台功

能。遥控机类可以作为电视机类的友元类。

```c++
#include <iostream>
using namespace std;

class Remote;

class Television {
	friend class Remote;

public:
	enum {on, off}; // 电视状态
	enum {minVol, maxVol = 100}; // 音量从0到100
	enum { minChannel = 1, maxChannel = 255 }; // 频道从1到255
	Television() {
		mState = off;
		mVolume = minVol;
		mChannel = minChannel;
	}

	// 打开电视机
	void OnOrOff() {
		this->mState = (this->mState = on ? off : on);
	}

	// 调高音量
	void VolumeUp() {
		if (this->mVolume >= maxVol) {
			return;
		}
		this->mVolume++;
	}


	// 调低音量
	void VolumeDown() {
		if (this->mVolume <= minVol) {
			return;
		}
		this->mVolume--;
	}

	// 频道+
	void ChannelUp() {
		if (this->mChannel >= maxChannel) {
			return;
		}
		this->mChannel++;
	}

	// 频道-
	void ChannelDown() {
		if (this->mChannel <= minChannel) {
			return;
		}
		this->mChannel--;
	}

	// 展示当前电视状态信息
	void showTeleState() {
		cout << "开机状态" << (mState == on ? "已开机" : "已关机") << endl;
		if (mState == on) {
			cout << "当前音量:" << mVolume << endl;
			cout << "当前频道:" << mChannel << endl;
		}
		cout << "-------------" << endl;
	}

private:
	int mState;
	int mVolume;
	int mChannel;
};

// 定义友元类
class Remote {
public:
	Remote(Television* television) {
		pTelevision = television;
	}

public:
	void OnOrOff() {
		pTelevision->OnOrOff();
	}
	//调高音量
	void VolumeUp() {
		pTelevision->VolumeUp();
	}
	//调低音量
	void VolumeDown() {
		pTelevision->VolumeDown();
	}
	//更换电视频道
	void ChannelUp() {
		pTelevision->ChannelUp();
	}
	void ChannelDown() {
		pTelevision->ChannelDown();
	}
	// 设置频道，遥控的新增功能
	void SetChannel(int channel) {
		if (channel < Television::minChannel || channel > Television::maxChannel) {
			return;
		}
		pTelevision->mChannel = channel;
	}
	//显示电视当前信息
	void ShowTeleState() {
		pTelevision->showTeleState();
	}

private:
	Television* pTelevision;
};

// 测试用例1：直接操作电视
void test01() {
	Television t;
	t.showTeleState(); // 已关机
	t.OnOrOff();	// 打开电视
	t.showTeleState(); // 开机状态已开机，当前音量:0，当前频道 : 1
	t.ChannelUp();
	t.showTeleState(); // 开机状态已开机，当前音量:0，当前频道 : 2
	t.VolumeUp();
	t.showTeleState(); // 开机状态已开机，当前音量:1，当前频道 : 2
}

// 测试用例2：通过遥控器操作电视
void test02() {
	Television t;
	Remote r(&t);
	r.ShowTeleState(); // 已关机
	r.OnOrOff();	// 打开电视
	r.ShowTeleState(); // 开机状态已开机，当前音量:0，当前频道 : 1
	r.ChannelUp();
	r.ShowTeleState(); // 开机状态已开机，当前音量:0，当前频道 : 2
	r.VolumeUp();
	r.ShowTeleState(); // 开机状态已开机，当前音量:1，当前频道 : 2
}

int main() {
	test02();
	return 0;
}
```

## 1.3 强化训练（数组类封装）

练习案例如下:

头文件 myarray.h

```c++
#pragma once

class MyArray {
public:
	// 无参构造函数，用户没有指定容量，则初始化为100
	MyArray();

	// 有参构造函数，用户指定容量初始化
	explicit MyArray(int capacity);

	// 用户操作接口
	// 根据位置添加元素
	void SetData(int pos, int val);

	// 获得指定位置数据
	int GetData(int pos);

	// 尾插法
	void PushBack(int val);

	// 获得长度
	int GetLength();

	// 析构函数
	~MyArray();

private:
	int mCapacity;
	int mSize;
	int* pAddress;
};
```

实现文件 myarray.cpp

```c++
#include "myarray.h"

// 无参构造函数
MyArray::MyArray() {
    // 默认容量100
	this->mCapacity = 100;
	this->mSize = 0;
	// 在堆区开辟空间
	this->pAddress = new int[this->mCapacity];
}

// 有参构造函数
MyArray::MyArray(int capacity) {
	this->mCapacity = capacity;
	this->mSize = 0;
	this->pAddress = new int[capacity];
}

// 析构函数, 释放数组空间
MyArray::~MyArray() {
	if (this->pAddress != nullptr) {
		delete[] this->pAddress;
	}
}

// 根据位置添加元素
void MyArray::SetData(int pos, int val) {
	if (pos <0 || pos > mCapacity - 1) {
		return;
	}

	pAddress[pos] = val;
}

// 获得指定位置的数据
int MyArray::GetData(int pos) {
	return pAddress[pos];
}

// 尾插法
void MyArray::PushBack(int val) {
	if (mSize >= mCapacity) {
		return;
	}

	this->pAddress[mSize] = val;
	this->mSize++;
}

// 获取长度
int MyArray::GetLength() {
	return this->mSize;
}
```

main文件

```c++
#include <iostream>
#include "myarray.h"
using namespace std;

void test() {
	// 创建数组
	MyArray myarray(5);

	// 数组插入元素
	for (int i = 0; i < 50; i++) {
		myarray.PushBack(i);
	}

	for (int i = 0; i < myarray.GetLength(); i++) {
		cout << myarray.GetData(i) << endl;
	}
	cout << endl;
}

int main() {
	test();
	return 0;
}
```

## 1.4 运算符重载(***)

### 1.4.1 运算符重载基本概念

运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。

在c++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是函数的名字由关键字

及其紧跟的运算符组成。差别仅此而已。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会

调用这个函数。

语法：

### 1.4.2 运算符重载碰上友元函数

友元函数是一个全局函数，和我们上例写的全局函数类似，只是友元函数可以访问某个类私有数据。

案例：友元重载运算符

```c++
#include <iostream>
#include "myarray.h"
using namespace std;

class Person {
	friend ostream& operator << (ostream& os, Person& person);
public:
	Person(int id, int age) {
		mId = id;
		mAge = age;
	}

private:
	int mId;
	int mAge;
};

ostream& operator << (ostream& os, Person& person) {
	os << "ID:" << person.mId << " Age: " << person.mAge;
	return os;
}

int main() {
	Person person(1001, 30);
	cout << person << endl;
	return 0;
}

# 输出：ID:1001 Age:30
```

### 1.4.3 可重载的运算符

几乎C中所有的运算符都可以重载，但运算符重载的使用时相当受限制的。特别是不能使用C中当前没有意义的运算符(例如用**求幂)不能改变运算符优先级，不能改变运算符的参数个数。这样的限制有意义，否则，所有这些行为产生的运算符只会混淆而不是澄清寓语意。

![img](../../../img/clip_image002-1691549951799.jpg)

### 1.4.4 自增/自减(++/--)运算符重载

重载的++和--运算符有点让人不知所措，因为我们总是希望能根据它们出现在所作用对象的前面还是后面来调用不同的函数。解决办法很简单，例如当编译器看到++a(前置++)，它就调用operator++(a),当编译器看到a++（后置++），它就会去调用operator++(a,int).

案例如下：

```c++
#include <iostream>
using namespace std;


class Complex {
	friend ostream& operator<<(ostream& os, Complex& complex) {
		os << "A:" << complex.mA << " ,B:" << complex.mB << endl;
		return os;
	}
public:
	Complex() {
		mA = 0;
		mB = 0;
	}

	// 重载前置
	Complex& operator++() {
		mA++;
		mB++;
		return *this;
	}

	// 重载后置++
	Complex operator++(int) {
		Complex temp;
		temp.mA = this->mA;
		temp.mB = this->mB;
		mA++;
		mB++;
		return temp;
	}

	// 前置--
	Complex& operator--() {
		mA--;
		mB--;
		return *this;
	}

	// 后置--
	Complex operator--(int) {
		Complex temp;
		temp.mA = mA;
		temp.mB = mB;
		mA--;
		mB--;
	}

	void showComplex() {
		cout << "A: " << mA << ",B: " << mB << endl;
	}

private:
	int mA;
	int mB;
};

void test() {
	Complex complex;
	complex++;
	cout << complex;
	++complex;
	cout << complex;

	Complex ret = complex++;
	cout << ret;
	cout << complex;

	cout << "---------" << endl;
}

int main() {
	test();
	return 0;
}
```

输出

```c++
A:1 ,B:1
A:2 ,B:2
A:2 ,B:2
A:3 ,B:3
---------
```

>**优先使用++和--的标准形式，优先调用前置++。**
>
>如果定义了++c，也要定义c++，递增操作符比较麻烦，因为他们都有前缀和后缀形式，而两种语义略有不同。重载operator++和operator--时应该模仿他们对应的内置操作符。
>
>对于++和--而言，后置形式是先返回，然后对象++或者--，返回的是对象的原值。前置形式，对象先++或--，返回当前对象，返回的是新对象。其标准形式为:
>
>![2016-07-12_132032](../../../img/clip_image002-1691654860393.jpg)
>
>调用代码时候，要优先使用前缀形式，除非确实需要后缀形式返回的原值，前缀和后缀形式语义上是等价的，输入工作量也相当，只是效率经常会略高一些，由于前缀形式少创建了一个临时对象。

### 1.4.5 指针运算符(*、->)重载

案例如下:

```c++
#pragma once
#include <iostream>
using namespace std;

// 4.6.5 指针运算符(*、->)重载

class Person {
public:
	Person(int param) {
		this->mParam = param;
	}

	void PrintPerson() {
		cout << "Param:" << mParam << endl;
	}

private:
	int mParam;
};

class Smartpointer {
public:
	Smartpointer(Person* person) {
		this->pPerson = person;
	}

	// 重载指针的->、*操作符
	Person* operator->() {
		return pPerson;
	}

	Person& operator*() {
		return *pPerson;
	}

	~Smartpointer() {
		if (pPerson != NULL) {
			delete pPerson;
		}
	}
public:
	Person* pPerson;

};

void test02() {
    //Person* person = new Person(100);
	//如果忘记释放，那么就会造成内存泄漏

    // 自定义的智能指针可自动释放
	Smartpointer pointer(new Person(100));
	pointer->PrintPerson();
}

int main() {
	test02();
	return 0;
}
```

输出

```c++
Param:100
```

### 1.4.6 赋值(=)号运算符重载

案例如下

```c++
#define _CRT_SECURE_NO_WARNINGS 
#include <iostream>
using namespace std;

class Person {
	friend ostream& operator<<(ostream& os, const Person& person) {
		os << "ID:" << person.mID << " Age:" << person.mAge << endl;
		return os;
	}
public:
	Person(int id, int age) {
		this->mID = id;
		this->mAge = age;
	}
	//重载赋值运算符
	Person& operator=(const Person& person) {
		this->mID = person.mID;
		this->mAge = person.mAge;
		return *this;
	}
private:
	int mID;
	int mAge;
};

//1. =号混淆的地方
void test01() {
	Person person1(10, 20);
	Person person2 = person1; //调用拷贝构造
	//如果一个对象还没有被创建，则必须初始化，也就是调用构造函数
	//上述例子由于person2还没有初始化，所以会调用构造函数
	//由于person2是从已有的person1来创建的，所以只有一个选择
	//就是调用拷贝构造函数
	person2 = person1; //调用operator=函数
	//由于person2已经创建，不需要再调用构造函数，这时候调用的是重载的赋值运算符
}
//2. 赋值重载案例
void test02() {
	Person person1(20, 20);
	Person person2(30, 30);
	cout << "person1:" << person1;
	cout << "person2:" << person2;
	person2 = person1;
	cout << "person2:" << person2;
}
//常见错误，当准备给两个相同对象赋值时，应该首先检查一下这个对象是否对自身赋值了
//对于本例来讲，无论如何执行这些赋值运算都是无害的，但如果对类的实现进行修改，那么将会出现差异；
//3. 类中指针
class Person2 {
	friend ostream& operator<<(ostream& os, const Person2& person) {
		os << "Name:" << person.pName << " ID:" << person.mID << " Age:" << person.mAge << endl;
		return os;
	}
public:
	Person2(const char name[5], int id, int age) {
		this->pName = new char[strlen(name) + 1];
		strcpy(this->pName, name);
		this->mID = id;
		this->mAge = age;
	}
#if 1
	//重载赋值运算符
	Person2& operator=(const Person2& person) {

		//注意:由于当前对象已经创建完毕，那么就有可能pName指向堆内存
		//这个时候如果直接赋值，会导致内存没有及时释放
		if (this->pName != NULL) {
			delete[] this->pName;
		}

		this->pName = new char[strlen(person.pName) + 1];
		strcpy(this->pName, person.pName);
		this->mID = person.mID;
		this->mAge = person.mAge;
		return *this;
	}
#endif
	//析构函数
	~Person2() {
		if (this->pName != NULL) {
			delete[] this->pName;
		}
	}
private:
	char* pName;
	int mID;
	int mAge;
};

void test03() {
	Person2 person1("John", 20, 20);
	Person2 person2("Edward", 30, 30);
	cout << "person1:" << person1;
	cout << "person2:" << person2;
	person2 = person1;
	cout << "person2:" << person2;
}

int main() {
	test02();
	printf("-----\n");
	test03();
	return 0;
}
```

输出

```c++
person1:ID:20 Age:20
person2:ID:30 Age:30
person2:ID:20 Age:20
-----
person1:Name:John ID:20 Age:20
person2:Name:Edward ID:30 Age:30
person2:Name:John ID:20 Age:20
```





