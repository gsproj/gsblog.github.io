

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="GongSheng">
  <meta name="keywords" content="">
  
    <meta name="description" content="一 继承介绍 继承是一种创建新类的方式，在Python中，新建的类可以继承一个或多个父类，新建的类可称为子类或派生类，父类又可称为基类或超类 class ParentClass1: #定义父类     pass  class ParentClass2: #定义父类     pass  class SubClass1(ParentClass1): #单继承     pass  class SubCl">
<meta property="og:type" content="article">
<meta property="og:title" content="25-继承与派生">
<meta property="og:url" content="http://gsproj.github.io/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/25_%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/index.html">
<meta property="og:site_name" content="迎风之豚的博客">
<meta property="og:description" content="一 继承介绍 继承是一种创建新类的方式，在Python中，新建的类可以继承一个或多个父类，新建的类可称为子类或派生类，父类又可称为基类或超类 class ParentClass1: #定义父类     pass  class ParentClass2: #定义父类     pass  class SubClass1(ParentClass1): #单继承     pass  class SubCl">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-e3ac39ed0476bd4ad372e51bea210c72_720w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-b61fc012e7821e82ed7a57bf446f238c_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-7c9d1a5d2778f92a7327f8733dcb419a_720w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-10df80634dbda00e4dcb4113c2a75b3c_720w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-d22528a722bfbb1765b99d1d75d8f1a4_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-a17f608a24f6f7dfc8d72c1394a8057f_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-b933b0de334a6cad2b227b53f3ae170a_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-3b3119b9824bc80de6d1c7cb11219a6d_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-80a1043173e8f968576b1efd57e857e9_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-7c6088a106bbf1fc46de0cca9c03a037_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-e75f3e5658ec15a3d5e964d32dce7d19_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-64faa1a6e825277233fe2bf40401b99b_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-e95d9f13b01af6eb7da3b5043442f697_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-08eb8fd2226110ae845da74805cb98fb_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-d21ae6052b43be565f551fc1fcabe5c3_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-908bf3b15e8a66ce55d1dc41155639ea_720w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-ad4967402d87e33226ff03f96801f350_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-80420dc0b3ecd5676e7b9d9f02f41aad_720w.jpg">
<meta property="article:published_time" content="2022-07-18T01:39:22.000Z">
<meta property="article:modified_time" content="2024-08-02T01:48:34.346Z">
<meta property="article:author" content="GongSheng">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pic3.zhimg.com/80/v2-e3ac39ed0476bd4ad372e51bea210c72_720w.jpg">
  
  
  
  <title>25-继承与派生 - 迎风之豚的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gsproj.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Haris的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="25-继承与派生"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-07-18 09:39" pubdate>
          2022年7月18日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          44 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">25-继承与派生</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="一-继承介绍"><a href="#一-继承介绍" class="headerlink" title="一 继承介绍"></a>一 继承介绍</h2><p><img src="https://pic3.zhimg.com/80/v2-e3ac39ed0476bd4ad372e51bea210c72_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>继承是一种创建新类的方式，在Python中，新建的类可以继承一个或多个父类，新建的类可称为子类或派生类，父类又可称为基类或超类</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class ParentClass1: #定义父类
    pass

class ParentClass2: #定义父类
    pass

class SubClass1(ParentClass1): #单继承
    pass

class SubClass2(ParentClass1,ParentClass2): #多继承
    pass</code></pre></div></figure>

<p>通过类的内置属性__bases__可以查看类继承的所有父类</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; SubClass2.__bases__
(&lt;class &#39;__main__.ParentClass1&#39;&gt;, &lt;class &#39;__main__.ParentClass2&#39;&gt;)</code></pre></div></figure>

<p><img src="https://pic1.zhimg.com/80/v2-b61fc012e7821e82ed7a57bf446f238c_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在Python2中有经典类与新式类之分，没有显式地继承object类的类，以及该类的子类，都是经典类，显式地继承object的类，以及该类的子类，都是新式类。而在Python3中，即使没有显式地继承object，也会默认继承该类，如下</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; ParentClass1.__bases__
(&lt;class ‘object&#39;&gt;,)
&gt;&gt;&gt; ParentClass2.__bases__
(&lt;class &#39;object&#39;&gt;,)</code></pre></div></figure>

<p>因而在Python3中统一都是新式类，关于经典类与新式类的区别，我们稍后讨论</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">提示：object类提供了一些常用内置方法的实现，如用来在打印对象时返回字符串的内置方法__str__</code></pre></div></figure>

<p><img src="https://pic3.zhimg.com/80/v2-7c9d1a5d2778f92a7327f8733dcb419a_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="二-继承与抽象"><a href="#二-继承与抽象" class="headerlink" title="二 继承与抽象"></a>二 继承与抽象</h2><p>要找出类与类之间的继承关系，需要先抽象，再继承。抽象即总结相似之处，总结对象之间的相似之处得到类，总结类与类之间的相似之处就可以得到父类，如下图所示</p>
<p><img src="https://pic1.zhimg.com/80/v2-10df80634dbda00e4dcb4113c2a75b3c_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>基于抽象的结果，我们就找到了继承关系</p>
<p><img src="https://pic1.zhimg.com/80/v2-d22528a722bfbb1765b99d1d75d8f1a4_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>基于上图我们可以看出类与类之间的继承指的是什么’是’什么的关系（比如人类，猪类，猴类都是动物类）。子类可以继承／遗传父类所有的属性，因而继承可以用来解决类与类之间的代码重用性问题。比如我们按照定义Student类的方式再定义一个Teacher类</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Teacher:
    school&#x3D;&#39;清华大学&#39;

    def __init__(self,name,sex,age):
        self.name&#x3D;name
        self.sex&#x3D;sex
        self.age&#x3D;age

    def teach(self):
        print(&#39;%s is teaching&#39; %self.name)</code></pre></div></figure>

<p><img src="https://pic4.zhimg.com/80/v2-a17f608a24f6f7dfc8d72c1394a8057f_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>类Teacher与Student之间存在重复的代码，老师与学生都是人类，所以我们可以得出如下继承关系，实现代码重用</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class People:
    school&#x3D;&#39;清华大学&#39;

    def __init__(self,name,sex,age):
        self.name&#x3D;name
        self.sex&#x3D;sex
        self.age&#x3D;age

class Student(People):
    def choose(self):
        print(&#39;%s is choosing a course&#39; %self.name)

class Teacher(People):
    def teach(self):
        print(&#39;%s is teaching&#39; %self.name)</code></pre></div></figure>

<p>Teacher类内并没有定义__init__方法，但是会从父类中找到__init__,因而仍然可以正常实例化，如下</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; teacher1&#x3D;Teacher(&#39;lili&#39;,&#39;male&#39;,18)
&gt;&gt;&gt; teacher1.school,teacher1.name,teacher1.sex,teacher1.age
(&#39;清华大学&#39;, &#39;lili&#39;, &#39;male&#39;, 18)</code></pre></div></figure>

<p><img src="https://pic3.zhimg.com/80/v2-b933b0de334a6cad2b227b53f3ae170a_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="三-属性查找"><a href="#三-属性查找" class="headerlink" title="三 属性查找"></a>三 属性查找</h2><p>有了继承关系，对象在查找属性时，先从对象自己的__dict__中找，如果没有则去子类中找，然后再去父类中找……</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class Foo:
...     def f1(self):
...         print(&#39;Foo.f1&#39;)
...     def f2(self):
...         print(&#39;Foo.f2&#39;)
...         self.f1()
... 
&gt;&gt;&gt; class Bar(Foo):
...     def f1(self):
...         print(&#39;Foo.f1&#39;)
... 
&gt;&gt;&gt; b&#x3D;Bar()
&gt;&gt;&gt; b.f2()
Foo.f2
Foo.f1</code></pre></div></figure>

<p>b.f2()会在父类Foo中找到f2，先打印Foo.f2,然后执行到self.f1(),即b.f1()，仍会按照：对象本身-&gt;类Bar-&gt;父类Foo的顺序依次找下去，在类Bar中找到f1，因而打印结果为Foo.f1</p>
<p><img src="https://pic2.zhimg.com/80/v2-3b3119b9824bc80de6d1c7cb11219a6d_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>父类如果不想让子类覆盖自己的方法，可以采用双下划线开头的方式将方法设置为私有的</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class Foo:
...     def __f1(self): # 变形为_Foo__fa
...         print(&#39;Foo.f1&#39;) 
...     def f2(self):
...         print(&#39;Foo.f2&#39;)
...         self.__f1() # 变形为self._Foo__fa,因而只会调用自己所在的类中的方法
... 
&gt;&gt;&gt; class Bar(Foo):
...     def __f1(self): # 变形为_Bar__f1
...         print(&#39;Foo.f1&#39;)
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; b&#x3D;Bar()
&gt;&gt;&gt; b.f2() #在父类中找到f2方法，进而调用b._Foo__f1()方法，同样是在父类中找到该方法
Foo.f2
Foo.f1</code></pre></div></figure>

<p><img src="https://pic2.zhimg.com/80/v2-80a1043173e8f968576b1efd57e857e9_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="四-继承的实现原理"><a href="#四-继承的实现原理" class="headerlink" title="四 继承的实现原理"></a>四 继承的实现原理</h2><h3 id="4-1-菱形问题"><a href="#4-1-菱形问题" class="headerlink" title="4.1 菱形问题"></a>4.1 菱形问题</h3><p> 大多数面向对象语言都不支持多继承，而在Python中，一个子类是可以同时继承多个父类的，这固然可以带来一个子类可以对多个不同父类加以重用的好处，但也有可能引发著名的 <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Diamond_problem">Diamond problem</a>菱形问题(或称钻石问题，有时候也被称为“死亡钻石”)，菱形其实就是对下面这种继承结构的形象比喻</p>
<p><img src="https://pic4.zhimg.com/80/v2-7c6088a106bbf1fc46de0cca9c03a037_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">A类在顶部，B类和C类分别位于其下方，D类在底部将两者连接在一起形成菱形。</code></pre></div></figure>

<p>这种继承结构下导致的问题称之为菱形问题：如果A中有一个方法，B和&#x2F;或C都重写了该方法，而D没有重写它，那么D继承的是哪个版本的方法：B的还是C的？如下所示</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class A(object):
    def test(self):
        print(&#39;from A&#39;)


class B(A):
    def test(self):
        print(&#39;from B&#39;)


class C(A):
    def test(self):
        print(&#39;from C&#39;)


class D(B,C):
    pass


obj &#x3D; D()
obj.test() # 结果为：from B</code></pre></div></figure>

<p>要想搞明白obj.test()是如何找到方法test的，需要了解python的继承实现原理</p>
<h3 id="4-2-继承原理"><a href="#4-2-继承原理" class="headerlink" title="4.2 继承原理"></a>4.2 继承原理</h3><p>python到底是如何实现继承的呢？ 对于你定义的每一个类，Python都会计算出一个方法解析顺序(MRO)列表，该MRO列表就是一个简单的所有基类的线性顺序列表，如下</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; D.mro() # 新式类内置了mro方法可以查看线性列表的内容，经典类没有该内置该方法
[&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;]</code></pre></div></figure>

<p>python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1.子类会先于父类被检查
2.多个父类会根据它们在列表中的顺序被检查
3.如果对下一个类存在两个合法的选择,选择第一个父类</code></pre></div></figure>

<p>所以obj.test()的查找顺序是，先从对象obj本身的属性里找方法test，没有找到，则参照属性查找的发起者(即obj)所处类D的MRO列表来依次检索，首先在类D中未找到，然后再B中找到方法test</p>
<p>ps：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">1.由对象发起的属性查找，会从对象自身的属性里检索，没有则会按照对象的类.mro()规定的顺序依次找下去，
2.由类发起的属性查找，会按照当前类.mro()规定的顺序依次找下去，</code></pre></div></figure>

<p><img src="https://pic2.zhimg.com/80/v2-e75f3e5658ec15a3d5e964d32dce7d19_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="4-3-深度优先和广度优先"><a href="#4-3-深度优先和广度优先" class="headerlink" title="4.3 深度优先和广度优先"></a>4.3 深度优先和广度优先</h3><p>参照下述代码，多继承结构为非菱形结构，此时，会按照先找B这一条分支，然后再找C这一条分支，最后找D这一条分支的顺序直到找到我们想要的属性</p>
<p><img src="https://pic4.zhimg.com/80/v2-64faa1a6e825277233fe2bf40401b99b_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class E:
    def test(self):
        print(&#39;from E&#39;)


class F:
    def test(self):
        print(&#39;from F&#39;)


class B(E):
    def test(self):
        print(&#39;from B&#39;)


class C(F):
    def test(self):
        print(&#39;from C&#39;)


class D:
    def test(self):
        print(&#39;from D&#39;)


class A(B, C, D):
    # def test(self):
    #     print(&#39;from A&#39;)
    pass


print(A.mro())
&#39;&#39;&#39;
[&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.E&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.F&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;object&#39;&gt;]
&#39;&#39;&#39;

obj &#x3D; A()
obj.test() # 结果为：from B
# 可依次注释上述类中的方法test来进行验证</code></pre></div></figure>

<p>如果继承关系为菱形结构，那么经典类与新式类会有不同MRO，分别对应属性的两种查找方式：深度优先和广度优先</p>
<p><img src="https://pic4.zhimg.com/80/v2-e95d9f13b01af6eb7da3b5043442f697_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class G: # 在python2中，未继承object的类及其子类，都是经典类
    def test(self):
        print(&#39;from G&#39;)

class E(G):
    def test(self):
        print(&#39;from E&#39;)

class F(G):
    def test(self):
        print(&#39;from F&#39;)

class B(E):
    def test(self):
        print(&#39;from B&#39;)

class C(F):
    def test(self):
        print(&#39;from C&#39;)

class D(G):
    def test(self):
        print(&#39;from D&#39;)

class A(B,C,D):
    # def test(self):
    #     print(&#39;from A&#39;)
    pass

obj &#x3D; A()
obj.test() # 如上图，查找顺序为:obj-&gt;A-&gt;B-&gt;E-&gt;G-&gt;C-&gt;F-&gt;D-&gt;object
# 可依次注释上述类中的方法test来进行验证,注意请在python2.x中进行测试</code></pre></div></figure>

<p><img src="https://pic4.zhimg.com/80/v2-08eb8fd2226110ae845da74805cb98fb_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class G(object):
    def test(self):
        print(&#39;from G&#39;)

class E(G):
    def test(self):
        print(&#39;from E&#39;)

class F(G):
    def test(self):
        print(&#39;from F&#39;)

class B(E):
    def test(self):
        print(&#39;from B&#39;)

class C(F):
    def test(self):
        print(&#39;from C&#39;)

class D(G):
    def test(self):
        print(&#39;from D&#39;)

class A(B,C,D):
    # def test(self):
    #     print(&#39;from A&#39;)
    pass

obj &#x3D; A()
obj.test() # 如上图，查找顺序为:obj-&gt;A-&gt;B-&gt;E-&gt;C-&gt;F-&gt;D-&gt;G-&gt;object
# 可依次注释上述类中的方法test来进行验证</code></pre></div></figure>

<h3 id="4-4-Pyton-Mixins机制"><a href="#4-4-Pyton-Mixins机制" class="headerlink" title="4.4 Pyton Mixins机制"></a>4.4 Pyton Mixins机制</h3><p> 一个子类可以同时继承多个父类，这样的设计常被人诟病，一来它有可能导致可恶的菱形问题，二来在人的世界观里继承应该是个”is-a”关系。 比如轿车类之所以可以继承交通工具类，是因为基于人的世界观，我们可以说：轿车是一个(“is-a”)交通工具，而在人的世界观里，一个物品不可能是多种不同的东西，因此多重继承在人的世界观里是说不通的，它仅仅只是代码层面的逻辑。不过有没有这种情况，一个类的确是需要继承多个类呢？</p>
<p> 答案是有，我们还是拿交通工具来举例子:</p>
<p> 民航飞机、直升飞机、轿车都是一个（is-a）交通工具，前两者都有一个功能是飞行fly，但是轿车没有，所以如下所示我们把飞行功能放到交通工具这个父类中是不合理的</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Vehicle:  # 交通工具
    def fly(self):
        &#39;&#39;&#39;
        飞行功能相应的代码        
        &#39;&#39;&#39;
        print(&quot;I am flying&quot;)


class CivilAircraft(Vehicle):  # 民航飞机
    pass


class Helicopter(Vehicle):  # 直升飞机
    pass


class Car(Vehicle):  # 汽车并不会飞，但按照上述继承关系，汽车也能飞了
    pass</code></pre></div></figure>

<p> 但是如果民航飞机和直升机都各自写自己的飞行fly方法，又违背了代码尽可能重用的原则（如果以后飞行工具越来越多，那会重复代码将会越来越多）。</p>
<p> 怎么办？？？为了尽可能地重用代码，那就只好在定义出一个飞行器的类，然后让民航飞机和直升飞机同时继承交通工具以及飞行器两个父类，这样就出现了多重继承。这时又违背了继承必须是”is-a”关系。这个难题该怎么解决？</p>
<p> 不同的语言给出了不同的方法，让我们先来了解Java的处理方法。Java提供了接口interface功能，来实现多重继承：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 抽象基类：交通工具类
public abstract class Vehicle &#123;
&#125;

&#x2F;&#x2F; 接口：飞行器
public interface Flyable &#123;
    public void fly();
&#125;

&#x2F;&#x2F; 类：实现了飞行器接口的类，在该类中实现具体的fly方法，这样下面民航飞机与直升飞机在实现fly时直接重用即可
public class FlyableImpl implements Flyable &#123;
    public void fly() &#123;
        System.out.println(&quot;I am flying&quot;);
    &#125;
&#125;



&#x2F;&#x2F; 民航飞机，继承自交通工具类，并实现了飞行器接口
public class CivilAircraft extends Vehicle implements Flyable &#123;
    private Flyable flyable;

    public CivilAircraft() &#123;
        flyable &#x3D; new FlyableImpl();
    &#125;

    public void fly() &#123;
        flyable.fly();
    &#125;
&#125;

&#x2F;&#x2F; 直升飞机，继承自交通工具类，并实现了飞行器接口
public class Helicopter extends Vehicle implements Flyable &#123;
    private Flyable flyable;

    public Helicopter() &#123;
        flyable &#x3D; new FlyableImpl();
    &#125;

    public void fly() &#123;
        flyable.fly();
    &#125;
&#125;

&#x2F;&#x2F; 汽车，继承自交通工具类，
public class Car extends Vehicle &#123;
&#125;</code></pre></div></figure>

<p>现在我们的飞机同时具有了交通工具及飞行器两种属性，而且我们不需要重写飞行器中的飞行方法，同时我们没有破坏单一继承的原则。飞机就是一种交通工具，可飞行的能力是飞机的属性，通过继承接口来获取。</p>
<p>回到主题，Python语言可没有接口功能，但Python提供了Mixins机制，简单来说Mixins机制指的是子类混合(mixin)不同类的功能，而这些类采用统一的命名规范（例如Mixin后缀），以此标识这些类只是用来混合功能的，并不是用来标识子类的从属”is-a”关系的，所以Mixins机制本质仍是多继承，但同样遵守”is-a”关系，如下</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Vehicle:  # 交通工具
    pass


class FlyableMixin:
    def fly(self):
        &#39;&#39;&#39;
        飞行功能相应的代码        
        &#39;&#39;&#39;
        print(&quot;I am flying&quot;)


class CivilAircraft(FlyableMixin, Vehicle):  # 民航飞机
    pass


class Helicopter(FlyableMixin, Vehicle):  # 直升飞机
    pass


class Car(Vehicle):  # 汽车
    pass

# ps: 采用某种规范（如命名规范）来解决具体的问题是python惯用的套路</code></pre></div></figure>

<p>可以看到，上面的CivilAircraft、Helicopter类实现了多继承，不过它继承的第一个类我们起名为FlyableMixin，而不是Flyable，这个并不影响功能，但是会告诉后来读代码的人，这个类是一个Mixin类，表示混入(mix-in)，这种命名方式就是用来明确地告诉别人（python语言惯用的手法），这个类是作为功能添加到子类中，而不是作为父类，它的作用同Java中的接口。所以从含义上理解，CivilAircraft、Helicopter类都只是一个Vehicle，而不是一个飞行器。</p>
<p>使用Mixin类实现多重继承要非常小心</p>
<ul>
<li>首先它必须表示某一种功能，而不是某个物品，python 对于mixin类的命名方式一般以 Mixin, able, ible 为后缀</li>
<li>其次它必须责任单一，如果有多个功能，那就写多个Mixin类，一个类可以继承多个Mixin，为了保证遵循继承的“is-a”原则，只能继承一个标识其归属含义的父类</li>
<li>然后，它不依赖于子类的实现</li>
<li>最后，子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。（比如飞机照样可以载客，就是不能飞了）</li>
</ul>
<p> Mixins是从多个类中重用代码的好方法，但是需要付出相应的代价，我们定义的Minx类越多，子类的代码可读性就会越差，并且更恶心的是，在继承的层级变多时，代码阅读者在定位某一个方法到底在何处调用时会晕头转向，如下</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Displayer:
    def display(self, message):
        print(message)


class LoggerMixin:
    def log(self, message, filename&#x3D;&#39;logfile.txt&#39;):
        with open(filename, &#39;a&#39;) as fh:
            fh.write(message)

    def display(self, message):
        super().display(message) # super的用法请参考下一小节
        self.log(message)


class MySubClass(LoggerMixin, Displayer):
    def log(self, message):
        super().log(message, filename&#x3D;&#39;subclasslog.txt&#39;) 


obj &#x3D; MySubClass()
obj.display(&quot;This string will be shown and logged in subclasslog.txt&quot;)


# 属性查找的发起者是obj,所以会参照类MySubClass的MRO来检索属性
#[&lt;class &#39;__main__.MySubClass&#39;&gt;, &lt;class &#39;__main__.LoggerMixin&#39;&gt;, &lt;class &#39;__main__.Displayer&#39;&gt;, &lt;class &#39;object&#39;&gt;]

# 1、首先会去对象obj的类MySubClass找方法display，没有则去类LoggerMixin中找，找到开始执行代码
# 2、执行LoggerMixin的第一行代码：执行super().display(message)，参照MySubClass.mro(),super会去下一个类即类Displayer中找，找到display，开始执行代码，打印消息&quot;This string will be shown and logged in subclasslog.txt&quot;
# 3、执行LoggerMixin的第二行代码：self.log(message)，self是对象obj，即obj.log(message)，属性查找的发起者为obj，所以会按照其类MySubClass.mro(),即MySubClass-&gt;LoggerMixin-&gt;Displayer-&gt;object的顺序查找，在MySubClass中找到方法log，开始执行super().log(message, filename&#x3D;&#39;subclasslog.txt&#39;)，super会按照MySubClass.mro()查找下一个类，在类LoggerMixin中找到log方法开始执行，最终将日志写入文件subclasslog.txt</code></pre></div></figure>

<p>ps：课外了解小知识</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">Java只允许接口的多重继承。接口本质上是抽象基类，具有所有抽象方法，没有数据成员。
与java一样，python也有抽象类的概念但是同样需要借助模块实现，抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化，继承的子类必须实现抽象基类规定的方法，这样便可保证始终只有一个特定方法或属性的实现，并且不会产生歧义，因而也可以起到避免菱形问题的作用

java的interface：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;linhaifeng&#x2F;articles&#x2F;7340153.html#_label6
python的抽象基类：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;linhaifeng&#x2F;articles&#x2F;7340153.html#_label7</code></pre></div></figure>

<h2 id="五-派生与方法重用"><a href="#五-派生与方法重用" class="headerlink" title="五 派生与方法重用"></a>五 派生与方法重用</h2><p>子类可以派生出自己新的属性，在进行属性查找时，子类中的属性名会优先于父类被查找，例如每个老师还有职称这一属性，我们就需要在Teacher类中定义该类自己的__init__覆盖父类的</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class People:
...     school&#x3D;&#39;清华大学&#39;
...     
...     def __init__(self,name,sex,age):
...         self.name&#x3D;name
...         self.sex&#x3D;sex
...         self.age&#x3D;age
... 
&gt;&gt;&gt; class Teacher(People):
...     def __init__(self,name,sex,age,title): # 派生
...         self.name&#x3D;name
...         self.sex&#x3D;sex
...         self.age&#x3D;age
...         self.title&#x3D;title
...     def teach(self):
...         print(&#39;%s is teaching&#39; %self.name)
... 
&gt;&gt;&gt; obj&#x3D;Teacher(&#39;lili&#39;,&#39;female&#39;,28,&#39;高级讲师&#39;) #只会找自己类中的__init__，并不会自动调用父类的
&gt;&gt;&gt; obj.name,obj.sex,obj.age,obj.title
(&#39;lili&#39;, &#39;female&#39;, 28, &#39;高级讲师&#39;)</code></pre></div></figure>

<p>很明显子类Teacher中__init__内的前三行又是在写重复代码，若想在子类派生出的方法内重用父类的功能，有两种实现方式</p>
<p>方法一：“指名道姓”地调用某一个类的函数</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class Teacher(People):
...     def __init__(self,name,sex,age,title):
...         People.__init__(self,name,age,sex) #调用的是函数,因而需要传入self
...         self.title&#x3D;title
...     def teach(self):
...         print(&#39;%s is teaching&#39; %self.name)
...</code></pre></div></figure>

<p><img src="https://pic4.zhimg.com/80/v2-d21ae6052b43be565f551fc1fcabe5c3_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>方法二：super()</p>
<p>调用super()会得到一个特殊的对象，该对象专门用来引用父类的属性，且严格按照MRO规定的顺序向后查找</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; class Teacher(People):
...     def __init__(self,name,sex,age,title):
...         super().__init__(name,age,sex) #调用的是绑定方法，自动传入self
...         self.title&#x3D;title
...     def teach(self):
...         print(&#39;%s is teaching&#39; %self.name)
...</code></pre></div></figure>

<p>提示：在Python2中super的使用需要完整地写成super(自己的类名,self) ,而在python3中可以简写为super()。</p>
<p><img src="https://pic3.zhimg.com/80/v2-908bf3b15e8a66ce55d1dc41155639ea_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这两种方式的区别是：方式一是跟继承没有关系的，而方式二的super()是依赖于继承的，并且即使没有直接继承关系，super()仍然会按照MRO继续往后查找</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; #A没有继承B
... class A:
...     def test(self):
...         super().test()
... 
&gt;&gt;&gt; class B:
...     def test(self):
...         print(&#39;from B&#39;)
... 
&gt;&gt;&gt; class C(A,B):
...     pass
... 
&gt;&gt;&gt; C.mro() # 在代码层面A并不是B的子类，但从MRO列表来看，属性查找时，就是按照顺序C-&gt;A-&gt;B-&gt;object，B就相当于A的“父类”
[&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;,&lt;class ‘object&#39;&gt;]
&gt;&gt;&gt; obj&#x3D;C()
&gt;&gt;&gt; obj.test() # 属性查找的发起者是类C的对象obj，所以中途发生的属性查找都是参照C.mro()
from B</code></pre></div></figure>

<p>obj.test()首先找到A下的test方法，执行super().test()会基于MRO列表(以C.mro()为准)当前所处的位置继续往后查找()，然后在B中找到了test方法并执行。</p>
<p>关于在子类中重用父类功能的这两种方式，使用任何一种都可以，但是在最新的代码中还是推荐使用super()</p>
<p><img src="https://pic1.zhimg.com/80/v2-ad4967402d87e33226ff03f96801f350_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="六-组合"><a href="#六-组合" class="headerlink" title="六 组合"></a>六 组合</h2><p>在一个类中以另外一个类的对象作为数据属性，称为类的组合。组合与继承都是用来解决代码的重用性问题。不同的是：继承是一种“是”的关系，比如老师是人、学生是人，当类之间有很多相同的之处，应该使用继承；而组合则是一种“有”的关系，比如老师有生日，老师有多门课程，当类之间有显著不同，并且较小的类是较大的类所需要的组件时，应该使用组合，如下示例</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Course:
    def __init__(self,name,period,price):
        self.name&#x3D;name
        self.period&#x3D;period
        self.price&#x3D;price
    def tell_info(self):
        print(&#39;&lt;%s %s %s&gt;&#39; %(self.name,self.period,self.price))

class Date:
    def __init__(self,year,mon,day):
        self.year&#x3D;year
        self.mon&#x3D;mon
        self.day&#x3D;day
    def tell_birth(self):
       print(&#39;&lt;%s-%s-%s&gt;&#39; %(self.year,self.mon,self.day))

class People:
    school&#x3D;&#39;清华大学&#39;
    def __init__(self,name,sex,age):
        self.name&#x3D;name
        self.sex&#x3D;sex
        self.age&#x3D;age

#Teacher类基于继承来重用People的代码，基于组合来重用Date类和Course类的代码
class Teacher(People): #老师是人
    def __init__(self,name,sex,age,title,year,mon,day):
        super().__init__(name,age,sex)
        self.birth&#x3D;Date(year,mon,day) #老师有生日
        self.courses&#x3D;[] #老师有课程，可以在实例化后，往该列表中添加Course类的对象
    def teach(self):
        print(&#39;%s is teaching&#39; %self.name)


python&#x3D;Course(&#39;python&#39;,&#39;3mons&#39;,3000.0)
linux&#x3D;Course(&#39;linux&#39;,&#39;5mons&#39;,5000.0)
teacher1&#x3D;Teacher(&#39;lili&#39;,&#39;female&#39;,28,&#39;博士生导师&#39;,1990,3,23)

# teacher1有两门课程
teacher1.courses.append(python)
teacher1.courses.append(linux)

# 重用Date类的功能
teacher1.birth.tell_birth()

# 重用Course类的功能
for obj in teacher1.courses: 
    obj.tell_info()</code></pre></div></figure>

<p>此时对象teacher1集对象独有的属性、Teacher类中的内容、Course类中的内容于一身（都可以访问到），是一个高度整合的产物</p>
<p><img src="https://pic2.zhimg.com/80/v2-80420dc0b3ecd5676e7b9d9f02f41aad_720w.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="视频链接："><a href="#视频链接：" class="headerlink" title="视频链接："></a>视频链接：</h2><p>继承与派生</p>
<p><a href="https://link.zhihu.com/?target=https://www.bilibili.com/video/av73342471?p=100">https://www.bilibili.com/video/av73342471?p=100www.bilibili.com/video/av73342471?p=100</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Python/" class="category-chain-item">Python</a>
  
  
    <span>></span>
    
  <a href="/categories/Python/02-Python%E8%BF%9B%E9%98%B6/" class="category-chain-item">02_Python进阶</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>25-继承与派生</div>
      <div>http://gsproj.github.io/2022/07/18/03_Python/02_Python进阶/25_继承与派生/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>GongSheng</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年7月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/23_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" title="23-面向对象编程">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">23-面向对象编程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/18/03_Python/02_Python%E8%BF%9B%E9%98%B6/24_%E5%B0%81%E8%A3%85/" title="24-封装">
                        <span class="hidden-mobile">24-封装</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.29.0/components/prism-core.min.js" ></script>

  <script  src="https://lib.baomitu.com/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" ></script>

  <script  src="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
