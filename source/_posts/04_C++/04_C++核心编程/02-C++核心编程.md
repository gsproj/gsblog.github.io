---
title: 02-C++核心编程
date: 2023-3-29 14:12:22
categories:
- C++
- 05_C++核心编程
tags:
---

# 一、类和对象

## 1.1 类和对象基本概念

### 1.1.1 C和C++中struct的区别

C语言struct只有变量

C++struct中既有变量，又有函数

### 1.1.2 类的封装

#### 1.1.2.1 对象和封装

1）什么是对象？

我们编写程序的目的是为了解决现实中的问题，而这些问题都是由各种对象（事物）组成，我们在计算机中

要解决问题，首先要做就是要将这个问题的参与者：**对象**抽象到计算机程序中，也就是用程序语言表示现实

的事物。

2）如何用程序语言来表示对象？

对象都具有自身的属性，一些自身具有的行为，所以如果我们能把对象的属性和行为表示出来，那么就可以抽象出

来这个对象。比如我们要表示人这个对象，在**C语言**中，我们可以这么表示:

```c++
// 对象：人，用结构体表示
typedef struct Person {
	char name[48];
	int age;
}Person;
```

但是在c语言中，存在一个问题：行为和属性是分开的。

也就是说吃饭这个属性不属于某类对象，而属于所有的共同的数据，所以不单单是`PeopleEat函数`可以调用`Person的数据`，`AnimalEat`也可以调用`Person数据`，那么万一调用错误，将会导致问题发生。

以下代码在C编译通过，C++编译失败

```c
#include <stdio.h>

// 对象：人，属性
typedef struct Person {
	char name[48];
	int age;
}Person;

// 对象: 动物，属性
typedef struct Animal {
	char name[64];
	int age;
	int type;
}Animal;

// 行为：人吃饭
void PersonEat(Person *person) {
	printf("%s在吃人吃的饭\n", person->name);
}

// 行为：动物吃饭
void AnimalEat(Animal *animal) {
	printf("%s在吃动物吃的饭\n", animal->name);
}

int main() {
	Person person;
	strcpy(person.name, "小明");	// 输出"小明在吃动物吃的饭"
	person.age = 18;
	AnimalEat(&person);	

	return 0;
}
```

从这个案例我们应该可以体会到，属性和行为应该放在一起，一起表示一个具有属性和行为的对象。

假如某对象的某项属性不想被外界获知，比如说漂亮女孩的年龄不想被其他人知道，那么年龄这条属性应该作为女

孩自己知道的属性；或者女孩的某些行为不想让外界知道，只需要自己知道就可以。那么这种情况下，封装应该再

提供一种机制能够给属性和行为的访问权限控制住。所以说**封装特性包含两个方面，一个是属性和变量合成一个**

**整体，一个是给属性和函数增加访问权限。**

>封装：
>
> 1、把变量（属性）和函数（操作）合成一个整体，封装在一个类中
>
> 2、对变量和函数进行访问权限控制

#### 1.1.2.2 访问权限

访问权限分为三种：

1、在类的内部，没有访问权限之分，所有成员都可以互相访问

2、在类的外部，访问权限有意义，分为：public、private、protected

3、在类的外部，只有public修饰的成员才能被访问，在没有设置继承和派生时，private和protected是同等级的，外部不允许访问

| 访问属性  | 属性 | 对象内部 | 对象外部 |
| --------- | ---- | -------- | -------- |
| public    | 公有 | 可访问   | 可访问   |
| protected | 保护 | 可访问   | 不可访问 |
| provate   | 私有 | 可访问   | 不可访问 |

案例：创建类，添加访问权限

```c++
#include <iostream>
using namespace std;

class Person {
public:
	void Call() {
		cout << "个人介绍噼里啪啦！" << endl;
	}
public:
	int mTall; // 多高
protected:
	int mMoney; // 多富
private:
	int mAge; // 年龄，不想被外人知道
};

int main() {
	Person p;
	p.mTall = 180;
	p.Call();
	// p.mTall; 保护成员，外部无法访问 
	// p.mTall; 私有成员，外部无法访问
	return 0;
}
```

>扩展：
>
>上述代码将class换成struct也能编译运行，效果类似，它们两个的主要区别就是
>
> class默认访问权限为private，而struct默认访问权限为public

### 1.1.3 将成员变量设置为private

1、可赋予客户端访问数据的一致性。

如果成员变量不是public，客户端唯一能够访问对象的方法就是通过成员函数。如果类中所有public权限的成员都是函数，客户在访问类成员时只会默认访问函数，不需要考虑访问的成员需不需要添加(),这就省下了许多搔首弄耳的时间。

2、 可细微划分访问控制。

使用成员函数可使得我们对变量的控制处理更加精细。如果我们让所有的成员变量为public，每个人都可以读写它。如果我们设置为private，我们可以实现“不准访问”、“只读访问”、“读写访问”，甚至你可以写出“只写访问”

案例如下：

```c++
class AccessLevels{
public:
	//对只读属性进行只读访问
	int getReadOnly(){ return readOnly; }
	//对读写属性进行读写访问
	void setReadWrite(int val){ readWrite = val; }
	int getReadWrite(){ return readWrite; }
	//对只写属性进行只写访问
	void setWriteOnly(int val){ writeOnly = val; }
private:
	int readOnly; //对外只读访问
	int noAccess; //外部不可访问
	int readWrite; //读写访问
	int writeOnly; //只写访问
};
```

## 1.2 面向对象程序设计案例

### 1.2.1 设计立方体类

设计立方体类(Cube)，求出立方体的面积( 2\*a\*b + 2\*a\*c + 2\*b\*c )和体积( a \* b \* c)，分别用全局函数和成员函数判断两个立方体是否相等。

```c++
#include <iostream>
using namespace std;

// 立方体类
class Cube {
private:
	int height; // 高
	int weight;	// 宽
	int length;	// 长
public:
	// 设置长宽高
	void setHeight(int h) { this->height = h; }
	void setWeight(int w) { this->weight = w; }
	void setLength(int l) { this->length = l; }
	
	// 获取长宽高
	int getHeight() { return this->height; }
	int getWeight() { return this->weight; }
	int getLength() { return this->length; }

	// 计算面积
	int calculateS() {
		return (height * length + height * weight + weight * length) * 2;
	}

	// 计算体积
	int calculateV() {
		return height * length * weight;
	}

	//成员方法, 判断两个立方体是否相等
	bool CubCompare(Cube& c) {
		if (getLength() == c.getLength() && getWeight() == c.getWeight() && getHeight() == c.getHeight()) {
			return true;
		}
		return false;
	}

};


int main() {
	Cube c1;
	c1.setHeight(10);
	c1.setLength(5);
	c1.setWeight(8);

	Cube c2;
	c2.setHeight(20);
	c2.setLength(35);
	c2.setWeight(48);

	Cube c3;
	c3.setHeight(10);
	c3.setLength(5);
	c3.setWeight(8);

	cout << "c1的面积是: " << c1.calculateS() << endl;	// 340
	cout << "c2的体积是: " << c2.calculateV() << endl;	// 33600
	cout << "c1和c2是否一样？ " << c1.CubCompare(c2) << endl;	 // 0 
	cout << "c1和c3是否一样？ " << c1.CubCompare(c3) << endl;	 // 1

	return 0;
}
```

### 1.2.2 点和圆的关系

设计一个圆形类（AdvCircle），和一个点类（Point），计算点和圆的关系。

假如圆心坐标为x0, y0, 半径为r，点的坐标为x1, y1：

1）点在圆上：(x1-x0)\*(x1-x0) + (y1-y0)\*(y1-y0) == r*r

2）点在圆内：(x1-x0)\*(x1-x0) + (y1-y0)\*(y1-y0) < r*r

3）点在圆外：(x1-x0)\*(x1-x0) + (y1-y0)\*(y1-y0) > r*r

```c++
#include <iostream>
using namespace std;

//点类
class Point {
public:
	void setX(int x) { mX = x; }
	void setY(int y) { mY = y; }
	int getX() { return mX; }
	int getY() { return mY; }
private:
	int mX;
	int mY;
};

//圆类
class Circle {
public:
	void setP(int x, int y) {
		mP.setX(x);
		mP.setY(y);
	}
	void setR(int r) { mR = r; }
	Point& getP() { return mP; }
	int getR() { return mR; }
	//判断点和圆的关系
	void IsPointInCircle(Point& point) {
		int distance = (point.getX() - mP.getX()) *
            (point.getX() - mP.getX()) +
            (point.getY() - mP.getY()) *
            (point.getY() - mP.getY());
		int radius = mR * mR;
		if (distance < radius) {
			cout << "Point(" << point.getX() << "," << point.getY() << ")在圆内!" << endl;
		}
		else if (distance > radius) {
			cout << "Point(" << point.getX() << "," << point.getY() << ")在圆外!" << endl;
		}
		else {
			cout << "Point(" << point.getX() << "," << point.getY() << ")在圆上!" << endl;
		}
	}
private:
	Point mP; //圆心
	int mR; //半径
};

void test() {
	//实例化圆对象
	Circle circle;
	circle.setP(20, 20);
	circle.setR(5);
	//实例化点对象
	Point point;
	point.setX(25);
	point.setY(20);

	circle.IsPointInCircle(point);
}



int main() {
	test();
	return 0;
}
```

## 1.3 对象的构造和析构

### 1.3.1 初始化和清理

我们大家在购买一台电脑或者手机，或者其他的产品，这些产品都有一个初始设置，也就是这些产品对被创建的时候会有一个基础属性值。那么随着我们使用手机和电脑的时间越来越久，那么电脑和手机会慢慢被我们手动创建很多文件数据，某一天我们不用手机或电脑了，那么我们应该将电脑或手机中我们增加的数据删除掉，保护自己的信息数据。

从这样的过程中，我们体会一下，所有的事物在起初的时候都应该有个初始状态，当这个事物完成其使命时，应该及时清除外界作用于上面的一些信息数据。

那么我们c++中OO思想也是来源于现实，是对现实事物的抽象模拟，具体来说，当我们创建对象的时候,这个对象应该有一个初始状态，当对象销毁之前应该销毁自己创建的一些数据。

对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始时，对其使用后果是未知，同样的使用完一个变量，没有及时清理，也会造成一定的安全问题。c++为了给我们提供这种问题的解决方案，**构造函数**和**析构函数**，这两个函数将会被编译器自动调用，完成对象初始化和对象清理工作。

**无论你是否喜欢，对象的初始化和清理工作是编译器强制我们要做的事情，即使你不提供初始化操作和清理操作，编译器也会给你增加默认的操作，只是这个默认初始化操作不会做任何事，所以编写类就应该顺便提供初始化函数。**

为什么初始化操作是自动调用而不是手动调用？既然是必须操作，那么自动调用会更好，如果靠程序员自觉，那么就会存在遗漏初始化的情况出现。

### 4.3.2 构造函数和析构函数

构造函数主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。

析构函数主要用于对象**销毁前**系统自动调用，执行一些清理工作。

**构造函数语法：**

  n   构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数。  n   ClassName(){}  

 

**析构函数语法：**

  n   析构函数函数名是在类名前面加”~”组成,没有返回值，不能有void,不能有参数，不能重载。  n   ~ClassName(){}  