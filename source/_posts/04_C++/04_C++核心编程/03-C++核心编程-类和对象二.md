---
title: 03-C++核心编程
date: 2023-4-26 9:42:22
categories:
- C++
- 05_C++核心编程
tags:
---

# 类和对象(二)

## 1.1 面向对象模型初探

### 1.1.1 成员变量和函数的存储

类的成员变量（数据）和成员函数（操作）是分开存储的：

- C++中的**非静态数据成员**是直接保存在类的对象的，就像c struct一样
- 成员函数虽然出现在类的声明中，但不保存在类的对象中
- 每一个**非内联成员函数**只会产生一份函数实例

如下演示案例：

```c++
#include <iostream>
using namespace std;

class MyClass01 {
public:
	int mA;	// 保存在类对象中，占4个字节
};

class MyClass02 {
public:
	int mA;	
	static int sB;	// 不保存在类对象中
};

class MyClass03 {
public:
	void printMyClass() {	// 不保存在类对象中
		cout << "Hello World！" << endl;
	}
public:
	int mA;
	static int sB;
};

class MyClass04 {
public:
	void printMyClass() {
		cout << "hello world!" << endl;
	}
	static void ShowMyClass() {	// 不保存在类对象中
		cout << "hello world！" << endl;
	}
public:
	int mA;
	static int sB;
};

int main() {
	MyClass01 mclass01;
	MyClass02 mclass02;
	MyClass03 mclass03;
	MyClass04 mclass04;

	cout << "MyClass01:" << sizeof(mclass01) << endl; //4
	//静态数据成员并不保存在类对象中
	cout << "MyClass02:" << sizeof(mclass02) << endl; //4
	//非静态成员函数不保存在类对象中
	cout << "MyClass03:" << sizeof(mclass03) << endl; //4
	//静态成员函数也不保存在类对象中
	cout << "MyClass04:" << sizeof(mclass04) << endl; //4

	return 0;
}
```

### 1.1.2 this指针

#### 1.1.2.1 this指针工作原理

通过上面的例子我们知道，C++的数据和操作也是分开存储，并且每一个非内联成员函数（non-inline member function）只会诞生一份函数实例，也就是说**多个同类型的对象会公用一块代码**

那么问题是，这一块代码是**如何区分到底是哪个对象调用自己的呢？**

![2016-05-10_213705](../../../img/clip_image002-1683684644687.jpg)

c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象。**

c++规定，this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的**每一个成员函数都含有一个**系统自动生成的**隐含指针this**，用以保存这个对象的地址，也就是说虽然我们没有写上this指针，编译器在编译的时候也是会加上的。因此this也称为“指向本对象的指针”，this指针并不是对象的一部分，不会影响sizeof(对象)的结果。

this指针是C++实现封装的一种机制，它将对象和该对象调用的成员函数连接在一起，在外部看来，每一个对象都拥有自己的函数成员。一般情况下，并不写this，而是让系统进行默认设置。

>   this指针永远指向当前对象。

成员函数通过this指针即可知道操作的是那个对象的数据。This指针是一种隐含指针，它隐含于每个类的非静态成员函数中。This指针无需定义，直接使用即可。

>注意：静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。

案例：c++编译器对普通成员函数的内部处理

![2016-04-12_010344](../../../img/clip_image002-1683688098742.jpg)

#### 1.1.2.2 this指针的使用

- 当形参和变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可使用return *this

案例如下：

```c++
#include <iostream>
#include <stdio.h>

using namespace std;

class Person {
public:
	// 1、当形参名和成员变量名一样时，this指针可用来区分
	Person(string name, int age) {
		this->name = name; // 区分this->name和name
		this->age = age;
	}

	// 2、返回对象本身的引用
	// 重载赋值操作
	// 其实也是两个参数，其中隐藏了一个this指针
	Person PersonPlusPerson(Person& person) {
		string newname = this->name + person.name;
		int newage = this->age + person.age;
		Person newperson(newname, newage);
		return newperson;
	}

	void ShowPerson() {
		cout << "Name: " << name << " Age: " << age << endl;
	}
public:
	string name;
	int age;
};

// 成员函数和全局函数(Person对象相加)
Person PersonPlusPerson(Person& p1, Person& p2) {
	string newname = p1.name + p2.name;
	int newage = p1.age + p2.age;
	Person newperson(newname, newage);
	return newperson;
}

int main() {
	Person p1("John", 100);
	p1.ShowPerson();

	cout << "-------" << endl;

	Person p2("Ladee", 20);
	Person p3("Oboo", 10);
	
	// 全局函数实现两个对象相加
	Person p4 = PersonPlusPerson(p2, p3);
	p2.ShowPerson();
	p3.ShowPerson();
	p4.ShowPerson();
	cout << "-------" << endl;


	// 成员函数实现两个对象相加
	Person p5 = p1.PersonPlusPerson(p2);
	p5.ShowPerson();

	system("pause");
}
```

#### 1.1.2.3 const修饰成员函数

作用如下：

- 用const修饰的成员函数时，const 修饰this指针指向的内存区域，成员函数体内不可以修改本类中的任何普通成员变量。
- 当成员函数变量类型符前用mutable修饰时例外。

使用案例：

```c++
#include <iostream>
using namespace std;

// const 修饰成员函数
class Person {
public:
	Person() {
		this->mAage = 0;
		this->mId = 0;
	}

	
	// 在函数括号后面加上const，修饰成员变量不可修改，除了mutable变量
	void someOperate() const {
		// this->mAage = 300; // mAge不可修改
		this->mId = 30;
	}

	void showPerson() {
		cout << "ID: " << this->mId << " Age: " << this->mAage;
	}

private:
	int mAage;
	mutable int mId;
};

int main() {
	Person p;
	p.someOperate();
	p.showPerson();	// ID: 30 Age: 0

	return 0;
}
```

#### 1.1.2.4 const修饰对象（常对象）

作用如下：

- 常对象只能调用const成员函数
- 常对象可访问const或非const数据成员，不能修改，除非成员用mutable修饰

```c++
#include <iostream>
using namespace std;

// const 修饰成员函数
class Person {
public:
	Person() {
		this->mAage = 0;
		this->mId = 0;
	}

	// 在函数括号后面加上const，修饰成员变量不可修改，除了mutable变量
	void someOperate() const {
		// this->mAage = 300; // mAge不可修改
		this->mId = 30;
	}

	void showPerson() {
		cout << "ID: " << this->mId << " Age: " << this->mAage;
	}

public:
	int mAage;
	mutable int mId;
};

int main() {
	// const 修饰对象
	const Person p;

	// 1、可访问数据成员, 但是不能修改, 除非有mutable修饰
	cout << "Age: " << p.mAage << ", ID: " << p.mId << endl;
	// p.mAage = 300; // 不可修改
	p.mId = 10; // 可以修改
	cout << "Age: " << p.mAage << ", ID: " << p.mId << endl;


	// 2、只能访问const修饰的成员函数
	p.someOperate(); // 可以访问
	// p.showPerson() // 不可访问

	return 0;
}
```

## 1.2 友元

什么是友元？

类的主要特点之一是**数据隐藏**，即类的私有成员无法在类的外部（作用域之外）访问。但是有时候**需要在类的外**

**部访问类的私有成员**，怎么办？

解决方法就是使用友元函数，友元函数是一种特权函数，C++允许这个特权函数访问私有成员。

这一点从现实生活中也很好理解：比如你的家，有客厅，有你的卧室，那么你的客厅是Public的，所有来的客人都

可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是呢，你也可以允许你的闺蜜好基友进去。

程序员可以把一个全局函数、某个类中的成员函数、甚至整个类声明为友元。

### 1.2.1 友元语法

使用方法如下：

- friend关键字只出现在声明处
- 其他类、类成员函数、全局函数都可声明为友元
- 友元函数不是类的成员，不带this指针
- 友元函数可访问对象任意成员属性，包括私有属性

案例：

```c++
#include <iostream>
using namespace std;

class Building;

// 友元类
class MyFriend {
public:
	// 友元成员函数
	void LookAtBedRoom(Building& building);
	void PlayInBedRoom(Building& building);
};

class Building {
	// 全局函数作为友元函数
	friend void CleanBedRoom(Building& building);

#if 0
	// 成员函数作为友元函数
	friend void MyFriend::LookAtBedRoom(Building& building);
	friend void MyFriend::PlayAtBedRoom(Building& building);
#else 
	friend class MyFriend;
#endif

public:
	Building();
public:
	string mSittingRoom;
private:
	string mBedroom;
};

void MyFriend::LookAtBedRoom(Building& building) {
	cout << "我的朋友参观" << building.mBedroom << endl;
}

void MyFriend::PlayInBedRoom(Building& building) {
	cout << "我的朋友玩耍" << building.mBedroom << endl;
}

// 友元全局函数
void CleanBedRoom(Building& building) {
	cout << "友元全局函数访问" << building.mBedroom << endl;
}

Building::Building() {
	this->mSittingRoom = "客厅";
	this->mBedroom = "卧室";
}

int main() {
	Building b;
	MyFriend m;

	CleanBedRoom(b);
	m.LookAtBedRoom(b);
	m.PlayInBedRoom(b);

	return 0;
}
```

>**<font color=red>友元类注意</font>**
>
>1．友元关系不能被继承。
>
>2．友元关系是单向的，类A是类B的朋友，但类B不一定是类A的朋友。
>
>友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。

**思考: c++是纯面向对象的吗？**

如果一个类被声明为friend,意味着它不是这个类的成员函数，却可以修改这个类的私有成员，而且必须列在类的定义中，因此他是一个特权函数。c++不是完全的面向对象语言，而只是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟c++设计的目的是为了实用性，而不是追求理想的抽象。

​                           																																											 --- Thinking in C++