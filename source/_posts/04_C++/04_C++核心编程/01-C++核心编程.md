---
title: 01-C++核心编程
date: 2023-3-27 9:24:22
categories:
- C++
- 05_C++核心编程
tags:
---

# <font color=blue>一、C++ 概述</font>

## <font color=darkyellow>1.1 C++简介</font>

什么是C++？

- c++中的++来自于c语言中的递增运算符++，该运算符将变量加1。c++起初也叫**c with clsss**，通过名称表明。
- c++是对C的扩展加强，因此c++是c语言的超集，是一种更好的C语言，这意味着任何有效的c程序都是有效的c++程序。c++程序可以使用已有的c程序库。
- c++语言在c语言的基础上添加了**面向对象编程**和**泛型编程**的支持。c++继承了c语言高效，简洁，快速和可移植的传统。

c++融合了3种不同的编程方式:

- c语言代表的过程性语言
- c++在c语言基础上添加的类代表的面向对象语言
- c++模板支持的泛型编程

# <font color=blue>二、C++初识</font>

## <font color=darkyellow>2.1 简单C++程序</font>

### <font color=green>2.2.1 HelloWorld代码</font>

C++的HelloWorld代码如下：

```c++
#include <iostream>	// 预编译指令
using namespace std;	// 使用标准命名空间

int main() {
	cout << "Hello World!" << endl;	// 和printf功能一样
	return 0;
}
```

### <font color=green>2.2.2 C++的头文件</font>

c++头文件为什么没有.h？

在c语言中头文件使用扩展名`.h`,将其作为一种通过名称标识文件类型的简单方式。但是c++得用法改变了，c++头文件没有扩展名。但是有些c语言的头文件被转换为c++的头文件，这些文件被重新命名，丢掉了扩展名.h(使之成为c++风格头文件)，并在文件名称前面加上前缀c(表明来自c语言)。

> 例如c++版本的math.h为cmath

由于C使用不同的扩展名来表示不同文件类型，因此用一些特殊的扩展名(如hpp或hxx)表示c++的头文件也是可以的，ANSI/IOS标准委员会也认为是可以的，但是关键问题是用哪个比较好，最后一致同意不使用任何扩展名。

| 头文件类型  | 约定               | 示例       | 说明                                        |
| ----------- | ------------------ | ---------- | ------------------------------------------- |
| c++旧式风格 | 以.h结尾           | iostream.h | c++程序可用                                 |
| c旧式风格   | 以.h结尾           | math.h     | c/c++程序可用                               |
| c++新式风格 | 无扩展名           | iostream   | c++程序可用，使用namespace std              |
| 转换后的c   | 加上前缀c,无扩展名 | cmath      | c++程序可用，可使用非c特性，如namespace std |

# <font color=blue>三、C++对C的扩展</font>

## <font color=darkyellow>3.1 `::`作用域运算</font>

通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。

```c++
//全局变量
int a = 10;
void test(){
	//局部变量
	int a = 20;
	//全局a被隐藏
	cout << "a = " << a << endl;	// 输出:a = 20
}
```

程序的输出结果是`a = 20`在test函数的输出语句中，使用的变量a是test函数内定义的局部变量，因此输出的结果为局部变量a的值。作用域运算符可以用来解决局部变量与全局变量的重名问题 ，如以下案例：

```c++
//全局变量
int a = 10;
//1. 局部变量和全局变量同名
void test(){
	int a = 20;
	//打印局部变量a
	cout << "局部变量a:" << a << endl;	// 20
	//打印全局变量a
	cout << "全局变量a:" << ::a << endl;	// 10
}
```

## <font color=darkyellow>3.2 命名空间</font>

创建`名字(name)`是程序设计过程中一项最基本的活动，当一个项目很大时，它会不可避免地包含大量名字，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等，工程越大，名称互相冲突性的可能性越大。另外使用多个厂商的类库时，也可能导致名称冲突，为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字`namespace`（命名空间/名字空间/名称空间），可以更好地控制标识符的作用域。

### <font color=green>3.2.1 命名空间的使用</font>

命名空间的常用方法

#### 3.2.1.1 创建命名空间

```c++
namespace A{
	int a = 10;
}
namespace B{
	int a = 20;
}
void test(){
	cout << "A::a : " << A::a << endl; // 10
	cout << "B::a : " << B::a << endl; // 20
}
```

> 命名空间只能全局范围内定义（**以下错误写法**）
>
> ```c++
> void test(){
> 	namespace A{	// error
> 		int a = 10;
> 	}
> 	namespace B{	// error
> 		int a = 20;
> 	}
> 	cout << "A::a : " << A::a << endl;
> 	cout << "B::a : " << B::a << endl;
> }
> 
> ```

#### 3.2.1.2 命名空间嵌套

命名空间可以嵌套使用

```c++
namespace A{
	int a = 10;
	namespace B{
		int a = 20;
	}
}
void test(){
	cout << "A::a : " << A::a << endl;
	cout << "A::B::a : " << A::B::a << endl;
}
```

#### 3.2.1.3 追加成员

命名空间是开放的，即可以随时把新的成员加入已有的命名空间中

```c++
namespace A{
	int a = 10;
}

// 往命名空间中追加新成员
namespace A{
	void func(){
		cout << "hello namespace!" << endl;
	}
}

void test(){
	cout << "A::a : " << A::a << endl;
	A::func();
}
```

#### 3.2.1.4 声明和实现分离

头文件声明

```c++
#pragma once

namespace MySpace{
	void func1();
	void func2(int param);
}
```

cpp文件实现

```c++
void MySpace::func1(){
	cout << "MySpace::func1" << endl;
}
void MySpace::func2(int param){
	cout << "MySpace::func2 : " << param << endl;
}
```

#### 3.2.1.5 无命名的空间

无名命名空间，意味着命名空间中的标识符**只能在本文件内访问**，相当于给这个标识符加上了static，使得其可以作为内部连接

```c++
namespace {	// 没有名字
	int a = 10;
	void func(){ cout << "hello namespace" << endl; }
}

void test(){
	cout << "a : " << a << endl;
	func();
}
```

#### 3.2.1.6 命名空间别名

命名空间可以设置别名，调用方法是一样的

```c++
// 创建命名空间
namespace veryLongName{
	int a = 10;
	void func(){ cout << "hello namespace" << endl; }
}

void test(){
    // 给命名空间创建别名
	namespace shortName = veryLongName;
	
    // 通过别名使用命名空间
    cout << "veryLongName::a : " << shortName::a << endl;
	veryLongName::func();
	shortName::func();
}
```

### <font color=green>3.2.2 using声明</font>

#### 3.2.2.1 using声明单个标识符

using声明可使得指定的标识符可用。

```c++
namespace A{
	int paramA = 20;
	int paramB = 30;
	void funcA(){ cout << "hello funcA" << endl; }
	void funcB(){ cout << "hello funcA" << endl; }
}

void test(){
	// 1. 通过命名空间直接访问
	cout << A::paramA << endl;
	A::funcA();
    
	// 2. 使用using声明单个标识符来访问
	using A::paramA;
	using A::funcA;
	cout << paramA << endl;
    
	// cout << paramB << endl; // 不可直接访问
	funcA();	// using声明过可以直接访问
    
	// 3. 同名冲突
	//int paramA = 20; // 相同作用域注意同名冲突
}
```

#### 3.2.2.2 using声明碰到函数重载

如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。

```c++
namespace A{
	void func(){}
	void func(int x){}
	int  func(int x,int y){}
}

void test(){
	using A::func;
    
    // 以下三个调用都能正常使用
	func();
	func(10);
	func(10, 20);
}
```

#### 3.2.2.3 using声明整个命令空间

using编译指令使整个命名空间的标识符可用.

```c++
namespace A{
	int paramA = 20;
	int paramB = 30;
	void funcA(){ cout << "hello funcA" << endl; }
	void funcB(){ cout << "hello funcB" << endl; }
}

void test01(){
	using namespace A;
	cout << paramA << endl;
	cout << paramB << endl;
	funcA();
	funcB();

	//不会产生二义性
	int paramA = 30;
	cout << paramA << endl;
}

namespace B{
	int paramA = 20;
	int paramB = 30;
	void funcA(){ cout << "hello funcA" << endl; }
	void funcB(){ cout << "hello funcB" << endl; }
}

void test02(){
	using namespace A;
	using namespace B;
	//二义性产生，不知道调用A还是B的paramA
	//cout << paramA << endl;
}
```

## 3.3 全局变量检测增强

C++在C语言的基础上增强了对全局变量的检测，如以下代码，在C编译器中将编译成功，在C++编译器中将编译失败：

```c++
int a = 10;
int a;

int main() {
    printf("%d\n", a);
    return 0;
}
```

编译执行结果：

```shell
gs@GreatWall-greatwall:~/C-Demo$ gcc test.c
gs@GreatWall-greatwall:~/C-Demo$ ./a.out
10
gs@GreatWall-greatwall:~/C-Demo$ g++ test.c
test.c:4:5: 错误： ‘int a’ 重定义
    4 | int a;
      |     ^
test.c:3:5: 附注： ‘int a’ previously defined here
    3 | int a = 10;
      |     ^
```

## 3.4 所有的变量和函数必须有类型

C++中所有的变量和函数都必须有类型，如以下代码，在C中可以编译执行，在C++中失败

```c
#include <stdio.h>

// 形参i不指定类型，实参可以是任意类型
int func1(i) {
    printf("i = %d\n", i);
    return 0;
}

// 形参i不指定类型，实参可以是任意类型
int func2(i) {
    printf("i = %s\n", i);
    return 0;
}

// 不写形参，可以传任何实参
int func3() {
    printf("func33\n");
    return 0;
}

// C语言如果没有参数，建议写void，代表没有参数
int func4(void) {
    printf("func4\n");
    return 0;
}

// 返回值没有类型
func5() {
    return 10;
}

// 返回值没有类型
func6() {
    return "Good Job";
}

int main() {
    func1(10086);
    func2("这是移动的电话");
    func3();
    func4();
    printf("func5的执行结果: %d\n", func5);
    printf("func6的执行结果: %s\n", func6);
    return 0;
}
```

编译执行结果：

```shell
# gcc编译成功
gs@GreatWall-greatwall:~/C-Demo$ gcc test.c
test.c: 在函数‘func1’中:
test.c:4:5: 警告： ‘i’的类型默认为‘int’ [-Wimplicit-int]
    4 | int func1(i) {
      |     ^~~~~
test.c: 在函数‘func2’中:
test.c:10:5: 警告： ‘i’的类型默认为‘int’ [-Wimplicit-int]
   10 | int func2(i) {
      |     ^~~~~
test.c: 在文件作用域：
test.c:28:1: 警告： 返回类型默认为‘int’ [-Wimplicit-int]
   28 | func5() {
      | ^~~~~
test.c:33:1: 警告： 返回类型默认为‘int’ [-Wimplicit-int]
   33 | func6() {
      | ^~~~~
test.c: 在函数‘func6’中:
test.c:34:12: 警告： returning ‘char *’ from a function with return type ‘int’ makes integer from pointer without a cast [-Wint-conversion]
   34 |     return "Good Job";
      |            ^~~~~~~~~~

# 执行成功
gs@GreatWall-greatwall:~/C-Demo$ ./a.out
i = 10086
i = 这是移动的电话
func33
func4
func5的执行结果: 10
func6的执行结果: Good Job

# g++编译失败
gs@GreatWall-greatwall:~/C-Demo$ g++ test.c
test.c:4:11: 错误： ‘i’在此作用域中尚未声明
    4 | int func1(i) {
      |           ^
test.c:10:11: 错误： ‘i’在此作用域中尚未声明
   10 | int func2(i) {
      |           ^
test.c:28:7: 错误： ISO C++ 不允许声明无类型的‘func5’ [-fpermissive]
   28 | func5() {
      |       ^
test.c:33:7: 错误： ISO C++ 不允许声明无类型的‘func6’ [-fpermissive]
   33 | func6() {
      |       ^
test.c: 在函数‘int func6()’中:
test.c:34:12: 错误： invalid conversion from ‘const char*’ to ‘int’ [-fpermissive]
   34 |     return "Good Job";
      |            ^~~~~~~~~~
      |            |
      |            const char*
test.c: 在函数‘int main()’中:
test.c:38:16: 错误： ‘func1’ cannot be used as a function
   38 |     func1(10086);
      |                ^
test.c:39:34: 错误： ‘func2’ cannot be used as a function
   39 |     func2("这是移动的电话");
      |                                  ^
```

>在C语言中，int fun() 表示返回值为int，接受任意参数的函数，int fun(void) 表示返回值为int的无参函数。
>
>在C++ 中，int fun() 和int fun(void) 具有相同的意义，都表示返回值为int的无参函数。

## 3.5 更严格的类型转换

在C++中不同类型的变量一般是不能直接赋值的，需要相应的强制类型转换，比如以下代码，在C下可编译通过，C++下编译失败：

```c
#include <stdio.h>
#include <stdlib.h>

typedef enum COLOR{
    GREEN, RED, YELLOW
}color;

int main() {
    color mycolor = GREEN;
    mycolor = 10;	// C++: invalid conversion from ‘int’ to ‘color’
    printf("mycolor: %d\n", mycolor);
    char* p = malloc(10); // C++: invalid conversion from ‘void*’ to ‘char*’
    return 0;
}
```

编译执行结果：

```shell
# gcc编译成功
gs@GreatWall-greatwall:~/C-Demo$ gcc test.c
gs@GreatWall-greatwall:~/C-Demo$ ./a.out
mycolor: 10
# g++编译失败
gs@GreatWall-greatwall:~/C-Demo$ g++ test.c
test.c: 在函数‘int main()’中:
test.c:10:15: 错误： invalid conversion from ‘int’ to ‘color’ {aka ‘COLOR’} [-fpermissive]
   10 |     mycolor = 10;
      |               ^~
      |               |
      |               int
test.c:12:21: 错误： invalid conversion from ‘void*’ to ‘char*’ [-fpermissive]
   12 |     char* p = malloc(10);
      |               ~~~~~~^~~~
      |                     |
      |                     void*
```

## 3.6 struct类型加强

改动有两方面：

- C中的结构体只能定义成员变量，不能定义成员函数，而C++的都可以定义
- C中定义结构体变量需要加上struct关键字，C++不需要

```c
#include <iostream>
using namespace std;

struct Student {
	// 既可以定义成员变量
	char name[64];
	int age;

	// 又可以定义成员函数
	int getAge() {
		return this->age;
	}
};

int main() {
	// 使用的时候还不需要struct
	// struct Student stu1;
	Student stu1 = { "张三", 18 };
	int age = stu1.getAge();
	printf("stu1 name = %s, age = %d\n", stu1.name, age);
}
```

## 3.7 bool类型

C++新增bool类型：true和false，转换为整形分别是1和0

- bool类型只有两个值，true(1值)，false(0值)
- bool类型占1个字节大小

```c++
#include <iostream>
using namespace std;

int main() {
	// 使用bool类型
	bool isEmpty = false;
	printf("isEmpty = %d\n", isEmpty);
}
```

>其实c语言中也有bool类型：
>
>在c99标准之前是没有bool关键字，c99标准已经有bool类型，包含头文件stdbool.h,就可以使用和c++一样的bool类型。

## 3.8 三目运算符功能增强

语言三目运算表达式返回值为数据值，为右值，不能赋值

```c
int a = 10;
int b = 20;
printf("ret:%d\n", a > b ? a : b);
//返回的是右值:10
```

c++语言三目运算表达式返回值为变量本身(引用)，为左值，可以赋值。

```c++
int a = 10;
int b = 20;
printf("ret:%d\n", a > b ? a : b);
//返回的是左值，变量的引用:b

(a > b ? a : b) = 100;//返回的是左值，变量的引用
cout << "b:" << b << endl;
```

## 3.9 const常量的改变

const单词表面意思为常数---不变的数，它在C/C++里面都有，是一个关键字，用于限定变量不允许修改（只读），它可以将一个对象转换成一个常量。

### 3.9.1 常量能否被修改

#### 3.9.1.1 全局const变量

**<font color=red>对于全局变量，都不可以修改</font>**

C/C++全局const变量的在内存中的存储位置：

- c语言中全局const会被存储到只读数据段。
- c++中全局const当声明extern或者对变量取地址时，编译器会分配存储地址，变量存储在只读数据段。

两个都受到了只读数据段的保护，不可修改。

```c
const int constA = 10;
int main() {
	int* p = (int*)&constA;
    *p = 200;
}
```

以上代码在c/c++中编译通过，在运行期，修改constA的值时，发生写入错误。原因是修改只读数据段的数据。

#### 3.9.1.2 局部const变量 

**<font color=red>对于局部变量，C可以改，C++不可以改</font>**

C语言中的局部const变量是假const变量：

- C语言中局部const可以通过指针修改。存储在堆栈区，只是不能通过变量直接修改const只读变量的值，但是可以跳过编译器的检查，通过指针间接修改const值。
- C++中局部const变量不可修改

```c
const int constA = 10;
int* p = (int*)&constA;
*p = 300;
printf("constA:%d\n",constA);
printf("*p:%d\n", *p);
```

c语言中，通过指针间接赋值修改了constA的值。

### 3.9.2 C++局部const变量的内存分配

#### 3.9.2.1 普通常量的内存分配1

对于基础数据类型，也就是`const int a = 10`这种，编译器会把它放到符号表中，不分配内存，当对其取地址时，会分配内存。

```c++
// 刚创建，不会分配内存，放到符号表中
const int constA = 10;
// 对其取地址时，会分配内存
int* p = (int*)&constA;
*p = 300;
cout << "constA:" << constA << endl;
cout << "*p:" << *p << endl;
```

constA在符号表中，当我们对constA取地址，这个时候为constA分配了新的空间，*p操作的是分配的空间，而constA是从符号表获得的值。

#### 3.9.2.2 普通常量的内存分配2

对于基础数据类型，如果用一个变量初始化const变量，如果const int a = b,那么也是会给a分配内存。

```c
int b = 10;
// constA 分配了内存，所以我们可以修改constA内存中的值
const int constA = b;
int* p = (int*)&constA;
*p = 300;
cout << "constA:" << constA << endl;
cout << "*p:" << *p << endl;
```

#### 3.9.2.3 自定义数据类型的内存分配

对于自定数据类型，比如类对象，那么也会分配内存。

```c
const Person person; //未初始化age
//person.age = 50; //不可修改
Person* pPerson = (Person*)&person;
//指针间接修改
pPerson->age = 100;
cout << "pPerson->age:" << pPerson->age << endl;
pPerson->age = 200;
cout << "pPerson->age:" << pPerson->age << endl;
```

为person分配了内存，所以我们可以通过指针的间接赋值修改person对象。

#### 3.9.2.4 内部连接和外部连接

C/C++默认的连接方式不一样

- c中const默认为外部连接
- c++中const默认为内部连接

当c语言**两个文件中**都有const int a的时候，编译器会报重定义的错误。

而在c++中，则不会，因为c++中的const默认是内部连接的。

如果想让c++中的const具有外部连接，必须显示声明为: extern const int a = 10;

案例如下：

文件test2.h

```c
const int a = 10;
```

文件test.c

```c
#include <stdio.h>
#include <stdlib.h>

// main.cpp定义
const int a = 10;

int main() {
        printf("a = %d\n", a);
        return 0;
}
```

编译并运行

```shell
# gcc编译失败，默认是外部连接，所以能探测到
gs@GreatWall-greatwall:~/C-Demo$ gcc test.c test2.c -o a.out
/usr/bin/ld: /tmp/ccHq7xrV.o:(.rodata+0x0): multiple definition of `a'; /tmp/cc2gZPeU.o:(.rodata+0x0): first defined here
collect2: 错误： ld 返回 1

# g++编译成功，默认是内部连接，只在test2.c中可见，所以探测不到
gs@GreatWall-greatwall:~/C-Demo$ g++ test.c test2.c -o a.out

# 执行
gs@GreatWall-greatwall:~/C-Demo$ ./a.out
a = 10
```

那么如何在C++中，将const常量改为外部连接？需要使用到`extern`修饰

文件test2.h

```c
extern const int a = 10;
```

文件test.c

```c
#include <stdio.h>
#include <stdlib.h>
// 引用外部变量
extern int a;


// main.cpp定义
// const int a = 10;

int main() {
        printf("a = %d\n", a);
        return 0;
}
```

执行结果：

```c
a = 10
```

如果这两个代码文件没有extern就编译：

```shell
# gcc编译通过，默认外部连接
gs@GreatWall-greatwall:~/C-Demo$ gcc test.c test2.c
gs@GreatWall-greatwall:~/C-Demo$ ./a.out
a = 10

# g++编译失败，找不到定义
gs@GreatWall-greatwall:~/C-Demo$ g++ test.c test2.c
/usr/bin/ld: /tmp/ccYQmUru.o: in function `main':
test.c:(.text+0x8): undefined reference to `a'
/usr/bin/ld: test.c:(.text+0xc): undefined reference to `a'
collect2: 错误： ld 返回 1
```

>**扩展**：能否用变量定义数组:
>
>在支持c99标准的编译器中，可以使用变量定义数组。
>
>1. 微软官方描述vs2013编译器不支持c99.： （VS不可以）
>
>Microsoft C conforms to the standard for the C language as set forth in the 9899:1990 edition of the ANSI C standard. 
>
>2. 以下代码在Linux GCC支持c99编译器编译通过	（GCC可以）
>
>```c
>// 定义变量
>int a = 10;
>// 用变量定义数组
>int arr[a];
>
>// 赋值并输出
>int i = 0;
>for(; i<10; i++) {
>    arr[i] = i;
>	i = 0;
>} 
>
>for(;i<10;i++) {
>   printf("%d\n",arr[i]); 
>}
>```

### 3.9.3 const和define的区别 

**C++中尽量用const替换#define**

在旧版本C中，如果想建立一个常量，可以使用预处理器

```c
#define MAX 1024;
```

我们定义的宏MAX**从未被编译器看到过**，因为在**预处理阶段，所有的MAX已经被替换为了1024**，于是MAX并没有将其加入到符号表中。但我们使用这个常量获得一个编译错误信息时，可能会带来一些困惑，因为这个信息可能会提到1024，但是并没有提到MAX.如果MAX被定义在一个不是你写的头文件中，你可能并不知道1024代表什么，也许解决这个问题要花费很长时间。

解决办法就是用一个常量替换上面的宏。

```c
const int max= 1024;
```

它们两个主要有以下区别：

| 对比项  | 是否有类型                       | 是否有作用域                                                 |
| ------- | -------------------------------- | ------------------------------------------------------------ |
| const   | 有类型，可进行编译器类型安全检查 | const有作用域                                                |
| #define | 无类型，不可进行类型检查.        | #define不重视作用域，默认定义到文件结尾或者遇到undef，如果定义在指定作用域下有有效的常量，那么#define就不能用。 |

>**扩展**：宏常量可以有命名空间吗？可以在命名空间中声明，但不能通过命名空间访问
>
>```c
>namespace MySpace{
>	#define num 1024	// 可以定义
>}
>void test(){
>	//cout << MySpace::NUM << endl; // 访问错误
>	//int num = 100; // 命名冲突
>	cout << num << endl;
>}
>```

## 3.10 引用（reference）



 