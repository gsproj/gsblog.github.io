---
title: Day58-Bootstrap
date: 2022-11-22 09:03:22
categories:
- 算法
tags:
---

"冒泡排序解析"

# 一、冒泡排序实现

使用C语言实现冒泡排序，输出： -2 3 7 8 20

```c
#include <stdio.h>

int main() {
    // 定义数组
    int num[] = {8, 20, -2, 3, 7};
   	// 定义需要用到的参数
    int i = 0; // 记录循环回合数
    int j = 0; // 记录对比数的下标
    int tmp = 0; // 用来交换的中间数
   	int n = sizeof(num) / sizeof(num[0]); // 记录数组大小
    
    // 外循环，记录回合数(总共需要对比n-1回合)
    for (i = 0; i < n - 1; i++) {
        // 内循环，轮流对比两个数，并交换位置
        for (j = 0; j < n - i - 1; j++) {
            if (num[j] > num[j+1]) {
            	tmp = num[j];
                num[j] = num[j+1];
                num[j+1] = tmp;
            }
        }
    }
    
    // 遍历输出
    for (i = 0; i < n; i++) {
        printf("%d ", num[i]);
    }
    printf("\n");
    

    return 0;
}
```

# 二、排序解释

冒牌排序的排序方法，分为外循环和内循环，外循环为`回合数`，内循环为`挑选元素`与`下一个元素`的比较，

## 2.1 外循环

如上面例子中的数组的外循环回合：

| 原数据   | 8    | 20   | -2   | 3    | 7    |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 第一回合 | 8    | -2   | 3    | 7    | 20   |
| 第二回合 | -2   | 3    | 7    | 8    | 20   |
| 第三回合 | -2   | 3    | 7    | 8    | 20   |
| 第四回合 | -2   | 3    | 7    | 8    | 20   |

像这个数组总共有5个元素，需要对比4个回合，即代码中的`(n-1)`

## 2.1 内循环

内循环：挑选一个数`num[j]`与它的下一个数`num[j+1]`比大小，如果前者比后者大，就互换位置

**外循环第一回合中的内循环：**

内循环第一次：8 与 20 比，不调换位置：{8,  20,  -2,  3,  7}

内循环第二次：20与-2比：调换位置：{8，-2，20，3，7}

内循环第三次：20与3比，调换位置：{8，-2，3，20，7}

内循环第四次：20与7比，调换位置：{8，-2，3，7，20}

**外循环第二回合中的内循环：**

内循环第一次：8 与 -2 比，调换位置：{-2，8，3，7，20}

内循环第二次：8与3比：调换位置：{-2，3，8，7，20}

内循环第三次：8与7比，调换位置：{-2，3，7，8，20}

经第一轮循环，最后一个已经是最大的，内循环四不需要

**虽然此时排序已经完成了，但是循环仍然会再走2次**

四个回合的内循环次数分别是：4、3、2、1，即代码中的`(n - i - 1)`